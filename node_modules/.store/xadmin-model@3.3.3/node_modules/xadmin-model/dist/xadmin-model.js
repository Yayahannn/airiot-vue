(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('xadmin-ui'), require('lodash'), require('xadmin'), require('react-router-dom'), require('recoil'), require('xadmin-i18n'), require('moment'), require('xadmin-form')) :
typeof define === 'function' && define.amd ? define(['exports', 'react', 'xadmin-ui', 'lodash', 'xadmin', 'react-router-dom', 'recoil', 'xadmin-i18n', 'moment', 'xadmin-form'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.xadminModel = {}, global.React, global.xadminUi, global._, global.xadmin, global.ReactRouterDOM, global.Recoil, global.xadminI18n, global.moment, global.xadminForm));
}(this, (function (exports, React, xadminUi, _$1, app$1, reactRouterDom, recoil, xadminI18n, moment, xadminForm) { 'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_$1);
var app__default = /*#__PURE__*/_interopDefaultLegacy(app$1);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _extends = unwrapExports(_extends_1);

var arrayLikeToArray = createCommonjsModule(function (module) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(arrayLikeToArray);

var arrayWithoutHoles = createCommonjsModule(function (module) {
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(arrayWithoutHoles);

var iterableToArray = createCommonjsModule(function (module) {
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(iterableToArray);

var unsupportedIterableToArray = createCommonjsModule(function (module) {
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(unsupportedIterableToArray);

var nonIterableSpread = createCommonjsModule(function (module) {
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(nonIterableSpread);

var toConsumableArray = createCommonjsModule(function (module) {
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _toConsumableArray = unwrapExports(toConsumableArray);

var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(objectWithoutPropertiesLoose);

var objectWithoutProperties = createCommonjsModule(function (module) {
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _objectWithoutProperties = unwrapExports(objectWithoutProperties);

var arrayWithHoles = createCommonjsModule(function (module) {
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(arrayWithHoles);

var iterableToArrayLimit = createCommonjsModule(function (module) {
function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(iterableToArrayLimit);

var nonIterableRest = createCommonjsModule(function (module) {
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(nonIterableRest);

var slicedToArray = createCommonjsModule(function (module) {
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _slicedToArray = unwrapExports(slicedToArray);

var defineProperty = createCommonjsModule(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _defineProperty = unwrapExports(defineProperty);

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var modelAtoms = function modelAtoms(k, model) {
  var ids = recoil.atom({
    key: k('ids'),
    "default": []
  });
  var item = recoil.atomFamily({
    key: k('item'),
    "default": {}
  });
  var items = recoil.selector({
    key: k('items'),
    get: function get(_ref) {
      var _get = _ref.get;
      return _get(ids).map(function (id) {
        return _get(item(id));
      }).filter(function (item) {
        return !___default['default'].isNil(item);
      });
    },
    set: function set(_ref2, newItems) {
      var _set = _ref2.set;
      var newIds = newItems.map(function (record) {
        if (___default['default'].isNil(record.id)) {
          // record without id field should throw warnning.
          return null;
        }

        _set(item(record.id), record);

        return record.id;
      }).filter(Boolean);

      _set(ids, newIds);
    }
  });
  var count = recoil.atom({
    key: k('count'),
    "default": 0
  });
  var selected = recoil.atom({
    key: k('selected'),
    "default": []
  });
  var option = recoil.atom({
    key: k('option'),
    "default": {}
  });

  var optionSelector = function optionSelector(key) {
    return recoil.selector({
      key: k(key),
      get: function get(_ref3) {
        var _get2 = _ref3.get;
        return _get2(option)[key];
      },
      set: function set(_ref4, value) {
        var get = _ref4.get,
            _set2 = _ref4.set;

        _set2(option, _objectSpread$6(_objectSpread$6({}, get(option)), {}, _defineProperty({}, key, value)));
      }
    });
  };

  var fields = optionSelector('fields');
  var order = optionSelector('order');
  var limit = optionSelector('limit');
  var skip = optionSelector('skip');
  var wheres = recoil.atom({
    key: k('wheres'),
    "default": {}
  });
  var where = recoil.selectorFamily({
    key: k('where'),
    get: function get(id) {
      return function (_ref5) {
        var get = _ref5.get;
        return get(wheres)[id];
      };
    },
    set: function set(id) {
      return function (_ref6, where) {
        var get = _ref6.get,
            set = _ref6.set;
        set(wheres, _objectSpread$6(_objectSpread$6({}, ___default['default'].omit(get(wheres), id)), !___default['default'].isEmpty(where) ? _defineProperty({}, id, where) : {}));
        set(skip, 0);
      };
    }
  });
  var loading = recoil.atomFamily({
    key: k('loading'),
    "default": false
  });
  var itemSelected = recoil.selectorFamily({
    key: k('itemSelected'),
    get: function get(id) {
      return function (_ref8) {
        var get = _ref8.get;
        return get(selected).find(function (item) {
          return item.id == id;
        }) !== undefined;
      };
    },
    set: function set(id) {
      return function (_ref9, isSelect) {
        var get = _ref9.get,
            set = _ref9.set;
        var selectedItems = get(selected).filter(function (i) {
          return i.id !== id;
        });

        if (isSelect) {
          selectedItems.push(get(item(id)));
        }

        set(selected, selectedItems);
      };
    }
  });
  var allSelected = recoil.selector({
    key: k('allSelected'),
    get: function get(_ref10) {
      var _get3 = _ref10.get;

      var selects = _get3(selected).map(function (item) {
        return item.id;
      });

      return ___default['default'].every(_get3(ids), function (id) {
        return selects.indexOf(id) >= 0;
      });
    },
    set: function set(_ref11, selectAll) {
      var get = _ref11.get,
          _set3 = _ref11.set;

      if (selectAll) {
        _set3(selected, ___default['default'].unionWith(get(selected), get(items), function (a, b) {
          return a.id == b.id;
        }));
      } else {
        _set3(selected, []);
      }
    }
  });
  var itemOrder = recoil.selectorFamily({
    key: k('itemOrder'),
    get: function get(field) {
      return function (_ref12) {
        var get = _ref12.get;
        var orders = get(order);
        return orders !== undefined ? orders[field] || '' : '';
      };
    },
    set: function set(field) {
      return function (_ref13, newOrder) {
        var get = _ref13.get,
            set = _ref13.set;
        var orders = get(order);
        set(order, _objectSpread$6(_objectSpread$6({}, orders), {}, _defineProperty({}, field, newOrder)));
      };
    }
  });
  return {
    ids: ids,
    item: item,
    items: items,
    selected: selected,
    count: count,
    option: option,
    optionSelector: optionSelector,
    fields: fields,
    order: order,
    limit: limit,
    skip: skip,
    wheres: wheres,
    where: where,
    loading: loading,
    itemSelected: itemSelected,
    allSelected: allSelected,
    itemOrder: itemOrder
  };
};

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var ModelContext = /*#__PURE__*/React__default['default'].createContext(null);

var getModel = function getModel(name, key, props) {
  var model = app$1.app.get('models')[name];

  if (!model) {
    throw Error("Model '".concat(name, "' not found!"));
  }

  model.name = model.name || name;
  return _objectSpread$5(_objectSpread$5({}, model), {}, {
    key: key || model.name
  }, props);
};

var DebugObserver = function DebugObserver() {
  var snapshot = recoil.useRecoilSnapshot();
  React__default['default'].useEffect(function () {
    if (!snapshot) return;
    console.debug('[Recoil] state change:');

    var _iterator = _createForOfIteratorHelper(snapshot.getNodes_UNSTABLE({
      isModified: true
    })),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        console.debug(node.key, snapshot.getLoadable(node));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, [snapshot]);
  return null;
};

var ModelInitial = function ModelInitial(_ref) {
  var model = _ref.model,
      initialValues = _ref.initialValues,
      children = _ref.children;
  var query = app$1.use('query');

  var _React$useState = React__default['default'].useState(true),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      loading = _React$useState2[0],
      setLoading = _React$useState2[1];

  var initializeState = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function () {
      var initial = initialValues || {};

      if (model.initialValues) {
        var modelInitial = ___default['default'].isFunction(model.initialValues) ? model.initialValues() : model.initialValues;
        initial = _objectSpread$5(_objectSpread$5({}, modelInitial), initial);
      }

      var _initial = initial,
          _initial$wheres = _initial.wheres,
          wheres = _initial$wheres === void 0 ? {} : _initial$wheres,
          option = _objectWithoutProperties(_initial, ["wheres"]);

      var defaultOpt = {
        fields: _toConsumableArray(model.listFields || []),
        order: model.defaultOrder || model.orders || {},
        limit: model.defaultPageSize || 15,
        skip: 0
      };

      if (query && !___default['default'].isEmpty(query)) {
        var filterQuery = Object.keys(query).reduce(function (p, key) {
          if (key.startsWith('f_')) {
            p[key.substring(2)] = query[key];
          }

          return p;
        }, {});

        if (!___default['default'].isEmpty(filterQuery)) {
          wheres.param_filter = filterQuery;
        }
      }

      set(model.atoms.option, _objectSpread$5(_objectSpread$5({}, defaultOpt), option));
      set(model.atoms.wheres, wheres);
    };
  }, [initialValues, model, query]);
  React__default['default'].useEffect(function () {
    initializeState();
    setLoading(false);
  }, []);
  return !loading ? children : null;
};

var Model = function Model(_ref3) {
  var name = _ref3.name,
      schema = _ref3.schema,
      modelKey = _ref3.modelKey,
      initialValues = _ref3.initialValues,
      children = _ref3.children,
      debug = _ref3.debug,
      modelProps = _ref3.props;
  var model = React__default['default'].useMemo(function () {
    var model = name ? getModel(name, modelKey, modelProps) : _objectSpread$5(_objectSpread$5({}, schema), {}, {
      key: modelKey || schema.name
    }, modelProps);
    var atoms = [modelAtoms].concat(_toConsumableArray(app$1.app.get('modelAtoms'))).reduce(function (p, getAtoms) {
      return _objectSpread$5(_objectSpread$5({}, p), getAtoms(function (id) {
        return "model.".concat(model.key, ".").concat(id);
      }, model));
    }, {});
    return _objectSpread$5(_objectSpread$5({}, model), {}, {
      atoms: atoms
    });
  }, [name, schema, modelKey]); // const initializeState = React.useCallback(({ set }) => {
  //   let initial = initialValues || {}
  //   if(model.initialValues) {
  //     let modelInitial = _.isFunction(model.initialValues) ? model.initialValues() : model.initialValues
  //     initial = { ...modelInitial, ...initial }
  //   }
  //   const { wheres={}, ...option } = initial
  //   const defaultOpt = {
  //     fields: [ ...(model.listFields || []) ],
  //     order: model.defaultOrder || model.orders || {},
  //     limit: model.defaultPageSize || 15,
  //     skip: 0
  //   }
  //   if(query && !_.isEmpty(query)) {
  //     wheres.param_filter = query
  //   }
  //   set(model.atoms.option, { ...defaultOpt, ...option })
  //   set(model.atoms.wheres, wheres)
  // }, [ initialValues, model, query ])

  return model && /*#__PURE__*/React__default['default'].createElement(recoil.RecoilRoot, {
    override: false
  }, (model.debug || debug) && /*#__PURE__*/React__default['default'].createElement(DebugObserver, null), /*#__PURE__*/React__default['default'].createElement(ModelContext.Provider, {
    value: model
  }, /*#__PURE__*/React__default['default'].createElement(ModelInitial, {
    initialValues: initialValues,
    model: model
  }, children)));
};

var ModelBlock = function ModelBlock(props) {
  return /*#__PURE__*/React__default['default'].createElement(ModelContext.Consumer, null, function (model) {
    return /*#__PURE__*/React__default['default'].createElement(app$1.Block, _extends({
      model: model
    }, props), function (blocks) {
      var modelBlock = model && model.blocks && model.blocks[props.name];

      if (modelBlock) {
        var mb = modelBlock(props);
        blocks = blocks ? [mb].concat(_toConsumableArray(blocks)) : [mb];
      }

      return props.children ? props.children(blocks) : blocks;
    });
  });
};

var ModelRoutes = function ModelRoutes() {
  var _use = app$1.use('model'),
      model = _use.model;

  var ModelList = model.components && model.components['ListPage'] || xadminUi.C('Model.ListPage');
  var ModelDetail = model.components && model.components['DetailPage'] || xadminUi.C('Model.DetailPage');
  var ModelAddForm = model.components && model.components['AddPage'] || xadminUi.C('Model.FormPage');
  var ModelEditForm = model.components && model.components['EditPage'] || xadminUi.C('Model.FormPage');
  return /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Routes, null, (!model.permission || model.permission.view) && /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Route, {
    path: "/",
    element: /*#__PURE__*/React__default['default'].createElement(ModelList, null)
  }), (!model.permission || model.permission.view) && /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Route, {
    path: "list",
    element: /*#__PURE__*/React__default['default'].createElement(ModelList, null)
  }), (!model.permission || model.permission.view) && /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Route, {
    path: ":id/detail",
    element: /*#__PURE__*/React__default['default'].createElement(ModelDetail, null)
  }), (!model.permission || model.permission.add) && /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Route, {
    path: "add",
    element: /*#__PURE__*/React__default['default'].createElement(ModelAddForm, null)
  }), (!model.permission || model.permission.edit) && /*#__PURE__*/React__default['default'].createElement(reactRouterDom.Route, {
    path: ":id/edit",
    element: /*#__PURE__*/React__default['default'].createElement(ModelEditForm, null)
  }));
};

var asyncToGenerator = createCommonjsModule(function (module) {
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _asyncToGenerator = unwrapExports(asyncToGenerator);

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

var getFieldProp = function getFieldProp(model, field) {
  return field.split('.').reduce(function (obj, f) {
    return obj && obj.properties && obj.properties[f];
  }, model);
};

var utils = /*#__PURE__*/Object.freeze({
__proto__: null,
getFieldProp: getFieldProp
});

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useModelRecoilAtom = function useModelRecoilAtom(atom, fkey) {
  var model = React.useContext(ModelContext);

  if (!model) {
    throw Error('Need Model Context when use model hooks.');
  }

  var state = atom;

  if (___default['default'].isFunction(atom)) {
    state = atom(model.atoms);
  } else if (___default['default'].isString(atom)) {
    state = model.atoms[atom];

    if (___default['default'].isNil(state)) {
      throw Error("Model atom ".concat(atom, " undefined."));
    }

    if (fkey) {
      state = state(fkey);
    }
  }

  return state;
};

var useModelValue = function useModelValue(atom, fkey) {
  return recoil.useRecoilValue(useModelRecoilAtom(atom, fkey));
};

var useModelState = function useModelState(atom, fkey) {
  return recoil.useRecoilState(useModelRecoilAtom(atom, fkey));
};

var useSetModelState = function useSetModelState(atom, fkey) {
  return recoil.useSetRecoilState(useModelRecoilAtom(atom, fkey));
};

var useModelCallback = function useModelCallback(cb, deps) {
  var _use = app$1.use('model'),
      model = _use.model,
      atoms = _use.atoms;

  return recoil.useRecoilCallback(function (proxy) {
    proxy.atoms = atoms;
    return cb(proxy);
  }, [].concat(_toConsumableArray(deps), [model]));
};

var hooks = {
  'model': function model() {
    var model = React.useContext(ModelContext);

    if (!model) {
      throw Error('Need Model Context when use model hooks.');
    }

    var rest = React.useMemo(function () {
      return app$1.api(model);
    }, [model]);
    return {
      model: model,
      rest: rest,
      atoms: model.atoms
    };
  },
  'model.value': useModelValue,
  'model.setter': useSetModelState,
  'model.state': useModelState,
  'model.callback': useModelCallback,
  // Get Model Item
  'model.get': function modelGet(_ref) {
    var id = _ref.id,
        query = _ref.query,
        item = _ref.item;

    var _use2 = app$1.use('model'),
        model = _use2.model,
        rest = _use2.rest;

    var defaultData = React__default['default'].useMemo(function () {
      var data = item;

      if (!data) {
        if (model.defaultValue) {
          data = ___default['default'].isFunction(model.defaultValue) ? model.defaultValue() : model.defaultValue;
        }

        if (!___default['default'].isEmpty(query)) {
          data = _objectSpread$4(_objectSpread$4({}, data), query);
        }
      }

      return data;
    }, [item, model.defaultValue, query]);

    var _useState = React.useState(function () {
      return {
        data: defaultData,
        loading: Boolean(!defaultData && id)
      };
    }),
        _useState2 = _slicedToArray(_useState, 2),
        state = _useState2[0],
        setState = _useState2[1];

    React.useEffect(function () {
      var data = state.data;

      if (id && (data === null || data === void 0 ? void 0 : data.id) != id) {
        setState({
          data: data,
          loading: true
        });
        rest.get(id).then(function (payload) {
          setState({
            data: payload,
            loading: false
          });
        });
      } else {
        setState({
          data: defaultData,
          loading: false
        });
      }
    }, [id]);
    var title = id ? xadminI18n._t('Edit {{title}}', {
      title: model.title
    }) : xadminI18n._t('Create {{title}}', {
      title: model.title
    });
    return _objectSpread$4({
      model: model,
      title: title
    }, state);
  },
  // Save Model Item
  'model.save': function modelSave(props) {
    var _use3 = app$1.use('model'),
        model = _use3.model,
        rest = _use3.rest;

    var message = app$1.use('message');
    var successMessage = props === null || props === void 0 ? void 0 : props.successMessage;
    var saveItem = useModelCallback(function (_ref2) {
      var snapshot = _ref2.snapshot,
          set = _ref2.set,
          atoms = _ref2.atoms;
      return /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(item, partial) {
          var data, id, newData, oldItem, selected, object, noticeMessage;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  set(atoms.loading('save'), true);
                  _context.prev = 1;

                  if (model.partialSave || item['__partial__']) {
                    partial = true;
                  }

                  _context.next = 5;
                  return rest.save(item, partial);

                case 5:
                  data = _context.sent;
                  id = data.id || item.id;
                  newData = data || item;

                  if (partial) {
                    oldItem = snapshot.getLoadable(atoms.item(id)).contents;
                    newData = _objectSpread$4(_objectSpread$4({}, oldItem), newData);
                  }

                  set(atoms.item(id), newData); // change selected item

                  selected = snapshot.getLoadable(atoms.selected).contents;
                  set(atoms.selected, selected.map(function (i) {
                    return i.id !== id ? i : newData;
                  }));

                  if (message !== null && message !== void 0 && message.success && successMessage !== false) {
                    object = model.title || model.name;
                    noticeMessage = successMessage || (item.id == undefined ? xadminI18n._t('Create {{object}} success', {
                      object: object
                    }) : xadminI18n._t('Save {{object}} success', {
                      object: object
                    }));
                    message.success(noticeMessage);
                  }

                  return _context.abrupt("return", data);

                case 16:
                  _context.prev = 16;
                  _context.t0 = _context["catch"](1);
                  app$1.app.error(_context.t0);
                  throw _context.t0.formError || _context.t0.json || _context.t0;

                case 20:
                  _context.prev = 20;
                  set(atoms.loading('save'), false);
                  return _context.finish(20);

                case 23:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 16, 20, 23]]);
        }));

        return function (_x, _x2) {
          return _ref3.apply(this, arguments);
        };
      }();
    }, []);
    return {
      model: model,
      saveItem: saveItem
    };
  },
  // Delete Model Item
  'model.delete': function modelDelete(props) {
    var _use4 = app$1.use('model'),
        model = _use4.model,
        rest = _use4.rest;

    var _use5 = app$1.use('model.getItems'),
        getItems = _use5.getItems;

    var message = app$1.use('message');
    var deleteMessage = props === null || props === void 0 ? void 0 : props.deleteMessage;
    var itemId = props === null || props === void 0 ? void 0 : props.id;
    var deleteItem = useModelCallback(function (_ref4) {
      var snapshot = _ref4.snapshot,
          set = _ref4.set,
          atoms = _ref4.atoms;
      return /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(id) {
          var selected;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  id = id || itemId;
                  _context2.next = 3;
                  return rest["delete"](id);

                case 3:
                  // unselect
                  selected = snapshot.getLoadable(atoms.selected).contents;
                  set(atoms.selected, selected.filter(function (i) {
                    return i.id !== id;
                  }));
                  (message === null || message === void 0 ? void 0 : message.success) && message.success(deleteMessage || xadminI18n._t('Delete {{object}} success', {
                    object: model.title || model.name
                  })); // getItems

                  _context2.next = 8;
                  return getItems();

                case 8:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x3) {
          return _ref5.apply(this, arguments);
        };
      }();
    }, [itemId]);
    return {
      model: model,
      deleteItem: deleteItem
    };
  },
  // Delete Model Item
  'model.getItems': function modelGetItems() {
    var _use6 = app$1.use('model'),
        model = _use6.model,
        rest = _use6.rest;

    var getItems = useModelCallback(function (_ref6) {
      var ss = _ref6.snapshot,
          set = _ref6.set,
          reset = _ref6.reset,
          atoms = _ref6.atoms;
      return /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(query) {
          var _ref8, newWheres, newOption, wheres, option, _yield$rest$query, items, total;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _ref8 = query || {}, newWheres = _ref8.wheres, newOption = _objectWithoutProperties(_ref8, ["wheres"]);
                  wheres = newWheres || ss.getLoadable(atoms.wheres).contents;
                  option = _objectSpread$4(_objectSpread$4({}, ss.getLoadable(atoms.option).contents), newOption);
                  set(atoms.loading('items'), true);
                  _context3.prev = 4;
                  _context3.next = 7;
                  return rest.query(option, wheres);

                case 7:
                  _yield$rest$query = _context3.sent;
                  items = _yield$rest$query.items;
                  total = _yield$rest$query.total;
                  set(atoms.items, items);
                  set(atoms.count, total);
                  if (!___default['default'].isEmpty(newOption)) set(atoms.option, option);
                  if (newWheres) set(atoms.wheres, wheres);
                  return _context3.abrupt("return", {
                    items: items,
                    total: total
                  });

                case 17:
                  _context3.prev = 17;
                  _context3.t0 = _context3["catch"](4);
                  app$1.app.error(_context3.t0);
                  reset(atoms.ids);
                  reset(atoms.count);
                  throw _context3.t0;

                case 23:
                  _context3.prev = 23;
                  set(atoms.loading('items'), false);
                  return _context3.finish(23);

                case 26:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[4, 17, 23, 26]]);
        }));

        return function (_x4) {
          return _ref7.apply(this, arguments);
        };
      }();
    }, []);
    return {
      model: model,
      getItems: getItems
    };
  },
  // Model Item hooks
  'model.item': function modelItem(props) {
    return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, app$1.use('model.get', props)), app$1.use('model.save', props)), app$1.use('model.delete', props));
  },
  'model.query': function modelQuery() {
    var _use7 = app$1.use('model'),
        model = _use7.model,
        rest = _use7.rest;

    var _useState3 = React.useState(null),
        _useState4 = _slicedToArray(_useState3, 2),
        data = _useState4[0],
        setData = _useState4[1];

    var _useState5 = React.useState(false),
        _useState6 = _slicedToArray(_useState5, 2),
        loading = _useState6[0],
        setLoading = _useState6[1];

    React.useEffect(function () {
      setLoading(true);
      rest.query().then(function (_ref9) {
        var items = _ref9.items;
            _ref9.count;
        setData(items);
        setLoading(false);
      });
    }, []);
    return {
      items: data,
      loading: loading,
      model: model
    };
  },
  'model.permission': function modelPermission() {
    var _use8 = app$1.use('model'),
        model = _use8.model;

    return {
      canAdd: !!model.permission && !!model.permission.add,
      canDelete: !!model.permission && !!model.permission["delete"],
      canEdit: !!model.permission && !!model.permission.edit
    };
  },
  'model.event': function modelEvent() {
    var _use9 = app$1.use('model'),
        model = _use9.model;

    var nav = app$1.use('navigate');
    return _objectSpread$4({
      onAdd: function onAdd() {
        return nav("../add");
      },
      onSaved: function onSaved() {
        return history && history.length > 1 && history.back() || nav("../");
      },
      onBack: function onBack() {
        return history && history.length > 1 && history.back() || nav(-1);
      },
      onEdit: function onEdit(id) {
        return nav("../".concat(encodeURIComponent(id || props.id), "/edit"));
      }
    }, model.events);
  },
  // Model effect hook
  'model.effect': function modelEffect() {
    var _use10 = app$1.use('model'),
        model = _use10.model;

    var _use11 = app$1.use('model.getItems'),
        getItems = _use11.getItems;

    var option = useModelValue('option');
    var wheres = useModelValue('wheres');
    React__default['default'].useEffect(function () {
      if (model.initQuery === false) {
        model.initQuery = undefined;
        return;
      }

      getItems();
    }, [option, wheres]);
    return null;
  },
  'model.pagination': function modelPagination() {
    app$1.use('model.atoms');
    var count = useModelValue('count');
    var limit = useModelValue('limit');

    var _useModelState = useModelState('skip'),
        _useModelState2 = _slicedToArray(_useModelState, 2),
        skip = _useModelState2[0],
        setSkip = _useModelState2[1];

    var items = Math.ceil(count / limit);
    var activePage = Math.floor(skip / limit) + 1;
    var changePage = React.useCallback(function (page) {
      var skip = limit * (page - 1);
      setSkip(skip);
    }, [setSkip, limit]);
    return {
      items: items,
      activePage: activePage,
      changePage: changePage
    };
  },
  'model.count': function modelCount() {
    return {
      count: useModelValue('count')
    };
  },
  'model.pagesize': function modelPagesize() {
    var _useModelState3 = useModelState('limit'),
        _useModelState4 = _slicedToArray(_useModelState3, 2),
        limit = _useModelState4[0],
        setLimit = _useModelState4[1];

    var setSkip = useSetModelState('skip');
    var sizes = app$1.config('pageSizes', [15, 30, 50, 100]);
    var setPageSize = React.useCallback(function (size) {
      setLimit(size);
      setSkip(0);
    }, [setLimit, setSkip]);
    return {
      sizes: sizes,
      setPageSize: setPageSize,
      size: limit
    };
  },
  'model.fields': function modelFields() {
    var _use12 = app$1.use('model'),
        model = _use12.model;

    var _useModelState5 = useModelState('fields'),
        _useModelState6 = _slicedToArray(_useModelState5, 2),
        selectedFields = _useModelState6[0],
        setFields = _useModelState6[1];

    var changeFieldDisplay = React.useCallback(function (_ref10) {
      var _ref11 = _slicedToArray(_ref10, 2),
          field = _ref11[0],
          selected = _ref11[1];

      var fs = _toConsumableArray(selectedFields);

      var index = ___default['default'].indexOf(fs, field);

      if (selected) {
        if (index === -1) fs.push(field);
      } else {
        ___default['default'].remove(fs, function (i) {
          return i === field;
        });
      }

      var list = Array.from(new Set([].concat(_toConsumableArray(model.listFields), _toConsumableArray(Object.keys(model.properties)))));
      setFields(list.filter(function (f) {
        return fs.indexOf(f) >= 0;
      }));
    }, [selectedFields, model, setFields]);
    return {
      fields: model.properties,
      changeFieldDisplay: changeFieldDisplay,
      selected: selectedFields
    };
  },
  'model.list': function modelList() {
    app$1.use('model.effect');
    var items = useModelValue('items');
    var selected = useModelValue('selected');
    var fields = useModelValue('fields');
    var loading = useModelValue('loading', 'items');
    return {
      loading: loading,
      items: items,
      fields: fields,
      selected: selected
    };
  },
  'model.actions': function modelActions() {
    var _use13 = app$1.use('model'),
        model = _use13.model;

    var modelActions = app$1.app.get('modelActions');
    var actions = model.itemActions === undefined ? Object.keys(modelActions).filter(function (k) {
      return modelActions[k]["default"];
    }) : model.itemActions;
    var renderActions = React__default['default'].useCallback(function (actProps) {
      return actions ? actions.map(function (action, i) {
        var Action = ___default['default'].isString(action) && modelActions[action] ? modelActions[action].component : action;

        if (Action) {
          return /*#__PURE__*/React__default['default'].createElement(Action, _extends({
            key: "model-action-".concat(i)
          }, actProps));
        }

        return null;
      }).filter(Boolean) : null;
    }, [actions]);
    return {
      actions: actions,
      renderActions: renderActions
    };
  },
  'model.select': function modelSelect() {
    var _use14 = app$1.use('model');
        _use14.atoms;

    var selected = useModelValue('selected');

    var _useModelState7 = useModelState('allSelected'),
        _useModelState8 = _slicedToArray(_useModelState7, 2),
        isSelectedAll = _useModelState8[0],
        onSelectAll = _useModelState8[1];

    var onSelect = useModelCallback(function (_ref12) {
      var set = _ref12.set,
          atoms = _ref12.atoms;
      return function (item, isSelect) {
        set(atoms.itemSelected(item.id), isSelect);
      };
    }, []);
    return {
      count: selected.length,
      selected: selected,
      isSelectedAll: isSelectedAll,
      onSelect: onSelect,
      onSelectAll: onSelectAll
    };
  },
  'model.list.row': function modelListRow(_ref13) {
    var id = _ref13.id;

    var _use15 = app$1.use('model'),
        model = _use15.model;

    var item = useModelValue('item', id);

    var _useModelState9 = useModelState('itemSelected', id),
        _useModelState10 = _slicedToArray(_useModelState9, 2),
        itemSelected = _useModelState10[0],
        changeSelect = _useModelState10[1];

    return {
      selected: itemSelected,
      item: item,
      changeSelect: changeSelect,
      actions: model.itemActions || ['edit', 'delete']
    };
  },
  'model.list.header': function modelListHeader(_ref14) {
    var field = _ref14.field;

    var _use16 = app$1.use('model'),
        model = _use16.model;

    var property = getFieldProp(model, field) || {};

    var title = property.header || property.title || ___default['default'].startCase(field);

    return {
      title: title
    };
  },
  'model.list.order': function modelListOrder(_ref15) {
    var field = _ref15.field;

    var _use17 = app$1.use('model'),
        model = _use17.model;

    var property = getFieldProp(model, field) || {};
    var canOrder = property.canOrder !== undefined ? property.canOrder : property.orderField !== undefined || property.type != 'object' && property.type != 'array';

    var _useModelState11 = useModelState('itemOrder', property.orderField || field),
        _useModelState12 = _slicedToArray(_useModelState11, 2),
        itemOrder = _useModelState12[0],
        changeOrder = _useModelState12[1];

    return {
      changeOrder: changeOrder,
      canOrder: canOrder,
      order: itemOrder
    };
  },
  'model.list.item': function modelListItem(_ref16) {
    var schema = _ref16.schema,
        field = _ref16.field,
        item = _ref16.item,
        nest = _ref16.nest;

    var _use18 = app$1.use('model'),
        model = _use18.model;

    var property = schema || getFieldProp(model, field);
    var data = schema ? {} : {
      schema: property
    };
    var key = schema ? "".concat(schema.name, ".").concat(field) : field;

    if (model.fieldRender == undefined) {
      model.fieldRender = {};
    }

    if (model.fieldRender[key] == undefined) {
      model.fieldRender[key] = property != undefined ? app$1.app.get('fieldRenders').reduce(function (prev, render) {
        return render(prev, property, field);
      }, null) : null;
    }

    if (model.fieldRender[key]) {
      data['componentClass'] = model.fieldRender[key];
    }

    data['value'] = ___default['default'].get(item, field);
    data['editable'] = nest == true || model.editableFields == undefined || model.editableFields.indexOf(field) < 0;
    return data;
  }
};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var fieldRenders = [function (SubPrev, schema) {
  if (schema.renderTemplate) {
    return function (_ref) {
      var value = _ref.value,
          WrapComponent = _ref.wrap,
          props = _objectWithoutProperties(_ref, ["value", "wrap"]);

      var html = ___default['default'].template(schema.renderTemplate)(_objectSpread$3({
        value: value
      }, props));

      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, /*#__PURE__*/React__default['default'].createElement("span", {
        dangerouslySetInnerHTML: {
          __html: html
        }
      }));
    };
  } else if (schema.type == 'string' && ['time', 'date', 'date-time', 'datetime'].indexOf(schema.format) > -1) {
    var dtf = app__default['default'].load_dict('config').date_format || {};
    var format = schema.dateFormat || {
      time: dtf.time || 'LT',
      date: dtf.date || 'LL',
      'date-time': dtf.datetime || 'LLL',
      'datetime': dtf.datetime || 'LLL'
    }[schema.format];
    return function (_ref2) {
      var value = _ref2.value,
          WrapComponent = _ref2.wrap;

      if (!___default['default'].isNil(value)) {
        var time = moment__default['default'](value);
        return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, time.format(format));
      } else {
        return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, /*#__PURE__*/React__default['default'].createElement("span", {
          className: "text-muted"
        }, "-"));
      }
    };
  } else if (schema.type == 'string' && schema["enum"] && schema.enum_title) {
    return function (_ref3) {
      var value = _ref3.value,
          WrapComponent = _ref3.wrap;
      var result = null;
      var index = schema["enum"].indexOf(value);

      if (___default['default'].isArray(schema.enum_title) && index > -1) {
        result = schema.enum_title[index];
      } else {
        result = schema.enum_title[value];
      }

      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, result || value);
    };
  } else if ((schema.type == 'number' || schema.type == 'integer') && schema["enum"] && schema.enum_title) {
    return function (_ref4) {
      var value = _ref4.value,
          WrapComponent = _ref4.wrap;
      var result = null;
      var index = schema["enum"].indexOf(value);

      if (___default['default'].isArray(schema.enum_title) && index > -1) {
        result = schema.enum_title[index];
      }

      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, result || value);
    };
  } else if (schema.type == 'boolean') {
    return function (_ref5) {
      var value = _ref5.value,
          WrapComponent = _ref5.wrap;
      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, {
        style: {
          textAlign: 'center'
        }
      }, /*#__PURE__*/React__default['default'].createElement(xadminUi.C, {
        is: "Model.BooleanIcon",
        value: value,
        schema: schema
      }));
    };
  } else if (schema.type == 'array') {
    return function (_ref6) {
      var value = _ref6.value,
          field = _ref6.field,
          WrapComponent = _ref6.wrap;
      var fieldName = "".concat(field, "__items");

      var itemWrap = function itemWrap(_ref7) {
        var children = _ref7.children;
        return /*#__PURE__*/React__default['default'].createElement("span", null, children, ', ');
      };

      var lastItemWrap = function lastItemWrap(_ref8) {
        var children = _ref8.children;
        return /*#__PURE__*/React__default['default'].createElement("span", null, children);
      };

      if (!___default['default'].isArray(value)) {
        if (___default['default'].isString(value)) {
          value = value.split(',');
        } else {
          value = [value];
        }
      }

      var renderValue = value ? value.map(function (item, index) {
        return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, {
          is: "Model.DataItem",
          nest: true,
          item: _defineProperty({}, fieldName, item),
          field: fieldName,
          schema: schema.items,
          wrap: value.length - 1 > index ? itemWrap : lastItemWrap
        });
      }) : null;
      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, renderValue);
    };
  } else if (schema.type == 'string' && schema.format == 'email') {
    return function (_ref10) {
      var value = _ref10.value,
          WrapComponent = _ref10.wrap;
      return /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, value ? /*#__PURE__*/React__default['default'].createElement("a", {
        href: "mailto:".concat(value)
      }, value) : '');
    };
  } else if (schema.type == 'object') {
    return function (_ref11) {
      var value = _ref11.value,
          wrap = _ref11.wrap;
      var displayField = schema.display_field || 'name';
      return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, {
        is: "Model.DataItem",
        nest: true,
        item: value,
        field: displayField,
        schema: schema.properties[displayField],
        wrap: wrap
      });
    };
  }

  return SubPrev;
}];

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var schema_converter = [function (f, schema, options) {
  if (schema.type == 'array' && schema.items.type == 'object' && schema.items.relateTo) {
    var models = app__default['default'].get('models');
    var name = schema.items.relateTo;

    if (models[name]) {
      var model = models[name];
      f.type = 'multi_select';
      f.schema = model;
      f.displayField = model.displayField || 'name';
    }
  }

  return f;
}, function (f, schema, options) {
  if (schema.type == 'object' && schema.relateTo) {
    var models = app__default['default'].get('models');
    var relateName = schema.relateTo;

    if (models[relateName]) {
      var model = models[relateName];
      f.type = 'fkselect';
      f.schema = model;
      f.displayField = model.displayField || 'name';
    }
  }

  return f;
}];
var filter_converter$1 = [function (f, schema, options) {
  if (schema.type == 'object' && schema.relateTo) {
    var models = app__default['default'].get('models');
    var relateName = schema.relateTo;

    if (models[relateName]) {
      var model = models[relateName];
      f.type = 'filter_relate';
      f.schema = model;
      f.displayField = model.displayField || 'name';
    }
  }

  return f;
}];
var RelateContext = /*#__PURE__*/React__default['default'].createContext();

var RelateContainer = function RelateContainer(_ref2) {
  var id = _ref2.id,
      children = _ref2.children;

  var _use2 = app$1.use('model'),
      model = _use2.model;

  var _use3 = app$1.use('model.get', {
    id: id
  }),
      data = _use3.data,
      loading = _use3.loading;

  return loading || data == undefined ? /*#__PURE__*/React__default['default'].createElement(xadminUi.Loading, null) : /*#__PURE__*/React__default['default'].createElement(xadminUi.C, {
    is: "Relate.Container",
    model: model,
    data: data
  }, /*#__PURE__*/React__default['default'].createElement(RelateContext.Provider, {
    value: {
      item: data,
      model: model
    }
  }, children));
};

var RelateWrap = function RelateWrap(SubComponent, pname) {
  return function (_ref3) {
    var location = _ref3.location,
        props = _objectWithoutProperties(_ref3, ["location"]);

    var _React$useContext = React__default['default'].useContext(RelateContext),
        item = _React$useContext.item,
        model = _React$useContext.model;

    return /*#__PURE__*/React__default['default'].createElement(SubComponent, _extends({}, props, {
      location: _objectSpread$2(_objectSpread$2({}, location), {}, {
        query: _objectSpread$2(_objectSpread$2({}, location.query), {}, _defineProperty({}, pname || model.name, item.id))
      })
    }));
  };
};

var routers = function routers(app) {
  var models = app.get('models');
  var _t = app.context._t;
  var names = Object.keys(models);
  var routes = {};

  var _loop = function _loop() {
    var name = _names[_i];
    var model = models[name];
    var modelName = model.title || model.name; // 每个model都加上relations页面

    routes["/app/model/".concat(name, "/")] = {
      path: ':id/relations/',
      breadcrumbName: _t('{{name}} List', {
        name: modelName
      }),
      component: function component(_ref4) {
        var id = _ref4.params.id,
            children = _ref4.children;
        return /*#__PURE__*/React__default['default'].createElement(RelateContainer, {
          id: id
        }, children);
      }
    }; // 循环判断每个Model的properties中的object对象

    for (var _i2 = 0, _Object$keys = Object.keys(model.properties || {}); _i2 < _Object$keys.length; _i2++) {
      var pname = _Object$keys[_i2];
      var prop = model.properties[pname];

      if (prop.type == 'object' && prop.relateTo && names.indexOf(prop.relateTo) > -1) {
        (function () {
          // 找到relate对象
          var relateName = prop.relateTo;
          models[relateName];
          var model_routes = [];

          if (!model.permission || model.permission.view) {
            model_routes.push({
              path: 'list',
              breadcrumbName: _t('{{name}} List', {
                name: modelName
              }),
              component: RelateWrap(model.components && (model.components['RelateListPage'] || model.components['ListPage']) || xadminUi.C('Relate.ListPage') || xadminUi.C('Model.ListPage'), pname)
            });
          }

          if (model.permission && model.permission.add) {
            model_routes.push({
              path: 'add',
              breadcrumbName: _t('Create {{name}}', {
                name: modelName
              }),
              component: RelateWrap(model.components && (model.components['RelateFormPage'] || model.components['FormPage']) || xadminUi.C('Relate.FormPage') || xadminUi.C('Model.FormPage'), pname)
            });
          }

          var key = "/app/model/".concat(relateName, "/:id/relations/");
          routes[key] = [].concat(_toConsumableArray(routes[key] || []), [{
            path: "".concat(name, "/"),
            breadcrumbName: _t('{{name}} List', {
              name: modelName
            }),
            component: function component(_ref5) {
              var children = _ref5.children;
              return /*#__PURE__*/React__default['default'].createElement(Model, {
                name: name,
                modelKey: "".concat(relateName, "_").concat(name)
              }, children);
            },
            indexRoute: {
              onEnter: function onEnter(_ref6, replace) {
                var location = _ref6.location;
                return replace({
                  pathname: location.pathname + 'list'
                });
              }
            },
            childRoutes: model_routes
          }]);
        })();
      }
    }
  };

  for (var _i = 0, _names = names; _i < _names.length; _i++) {
    _loop();
  }

  return routes;
};

var relate = {
  name: 'xadmin.model.relate',
  schema_converter: schema_converter,
  filter_converter: filter_converter$1,
  routers: routers,
  hooks: {
    'model.relate.select': function modelRelateSelect(_ref8) {
      var field = _ref8.field;

      var _use5 = app$1.use('model'),
          model = _use5.model;

      var _React$useState = React__default['default'].useState(false),
          _React$useState2 = _slicedToArray(_React$useState, 2),
          loading = _React$useState2[0],
          setLoadig = _React$useState2[1];

      var _React$useState3 = React__default['default'].useState([]),
          _React$useState4 = _slicedToArray(_React$useState3, 2),
          options = _React$useState4[0],
          setOptions = _React$useState4[1];

      var loadOptions = React__default['default'].useCallback(function (inputValue) {
        var displayField = field.displayField || 'name';
        setLoadig(true);
        return app$1.api(field.schema).query({
          limit: 1000,
          fields: ['id', displayField]
        }, inputValue ? {
          search: _defineProperty({}, displayField, {
            like: inputValue
          })
        } : {}).then(function (_ref9) {
          var items = _ref9.items;
          setLoadig(false);
          setOptions(items.map(function (item) {
            return {
              value: item.id,
              label: item[displayField],
              item: item
            };
          }));
        });
      }, [model, field]);
      React__default['default'].useEffect(function () {
        loadOptions();
      }, []);
      return {
        loadOptions: loadOptions,
        loading: loading,
        options: options
      };
    }
  }
};

var stripNullType = function stripNullType(type) {
  if (Array.isArray(type) && type.length == 2) {
    if (type[0] === 'null') return type[1];
    if (type[1] === 'null') return type[0];
  }

  return type;
};

var enumToTitleMap = function enumToTitleMap(enm, title) {
  var titleMap = [];
  enm.forEach(function (name, index) {
    titleMap.push({
      name: title != undefined ? (___default['default'].isArray(title) ? title[index] : title[name]) || name : name,
      value: name
    });
  });
  return titleMap;
};

var canonicalTitleMap = function canonicalTitleMap(titleMap, originalEnum) {
  if (!___default['default'].isArray(titleMap)) {
    var canonical = [];

    if (originalEnum) {
      originalEnum.forEach(function (value) {
        canonical.push({
          name: titleMap[value],
          value: value
        });
      });
    } else {
      for (var k in titleMap) {
        if (titleMap.hasOwnProperty(k)) {
          canonical.push({
            name: k,
            value: titleMap[k]
          });
        }
      }
    }

    return canonical;
  }

  return titleMap;
};

var filter_converter = [// all form field
function (f, fschema, options) {
  var schema = f.schema || fschema;
  f.key = options.key || schema.name;
  f.name = f.key;
  f.label = schema.title || f.name;

  if (schema.description) {
    f.description = schema.description;
  }

  if (schema.maxLength) {
    f.maxlength = schema.maxLength;
  }

  if (schema.minLength) {
    f.minlength = schema.minLength;
  }

  if (schema.minimum) {
    f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0);
  }

  if (schema.maximum) {
    f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0);
  }

  if (schema.validationMessage) {
    f.validationMessage = schema.validationMessage;
  }

  if (schema.enumNames) {
    f.titleMap = canonicalTitleMap(schema.enumNames, schema['enum']);
  }

  f.schema = schema;
  return f;
}, function (f, schema, options) {
  if (f.type !== undefined) {
    return f;
  }

  var schema_type = stripNullType(schema.type);

  if (schema_type === 'string') {
    if (!schema['enum']) {
      f.type = 'filter_text';
    } else {
      f.type = 'filter_enum';

      if (!f.titleMap) {
        f.titleMap = enumToTitleMap(schema['enum'], schema['enum_title'] || {});
      }
    }

    switch (schema.format) {
      case 'date':
        f.type = 'filter_date';
        break;

      case 'time':
        f.type = 'filter_time';
        break;

      case 'datetime':
        f.type = 'filter_datetime';
        break;

      case 'date-time':
        f.type = 'filter_datetime';
        break;
    }
  } else if (schema_type === 'number' || schema_type === 'integer') {
    if (!schema['enum']) {
      f.type = 'filter_number';
    } else {
      f.type = 'filter_enum';

      if (!f.titleMap) {
        f.titleMap = enumToTitleMap(schema['enum'], schema['enum_title'] || {});
      }
    }
  } else if (schema_type === 'boolean') {
    f.type = 'filter_bool';
  }

  return f;
}];

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var convert = function convert(schema, options) {
  var opts = options || {};
  return app__default['default'].load_list('filter_converter').reduce(function (prve, converter) {
    return converter(prve, schema, opts);
  }, {});
};

var FilterForm = function FilterForm(props) {
  var FilterComponent = props.component,
      filterForm = _objectWithoutProperties(props, ["component"]);

  var _use = app$1.use('model.list.filter'),
      resetFilter = _use.resetFilter;

  return /*#__PURE__*/React__default['default'].createElement(FilterComponent, _extends({}, filterForm, {
    resetFilter: resetFilter
  }));
};

var BaseFilter = function BaseFilter(props) {
  var name = props.name,
      _component = props.component,
      group = props.group,
      fieldProps = props.fieldProps;

  var _use2 = app$1.use('model'),
      model = _use2.model,
      atoms = _use2.atoms;

  var _useRecoilState = recoil.useRecoilState(atoms.where('filters')),
      _useRecoilState2 = _slicedToArray(_useRecoilState, 2),
      data = _useRecoilState2[0],
      setFilters = _useRecoilState2[1];

  var _React$useMemo = React__default['default'].useMemo(function () {
    var formKey = "filter.".concat(model.key || model.name);
    var filter = model.filters && model.filters[name];
    var fields, options;

    if (___default['default'].isArray(filter)) {
      options = {};
      fields = filter;
    } else if (___default['default'].isPlainObject(filter) && ___default['default'].isArray(filter.fields)) {
      fields = filter.fields;
      options = ___default['default'].omit(filter, 'fields');
    } else {
      return {
        filters: [],
        formKey: formKey,
        options: {}
      };
    }

    var filters = fields.map(function (field) {
      var key = typeof field == 'string' ? field : field.key;
      var schema = getFieldProp(model, key);
      return schema ? {
        key: key,
        schema: schema,
        field: typeof field == 'string' ? {} : field
      } : null;
    }).filter(Boolean);
    return {
      filters: filters,
      formKey: formKey,
      options: options
    };
  }, [model, name]),
      filters = _React$useMemo.filters,
      options = _React$useMemo.options;
      _React$useMemo.formKey;

  var fields = React__default['default'].useMemo(function () {
    return filters.map(function (filter) {
      var field = convert(filter.schema, {
        key: filter.key
      });
      return ___default['default'].merge(field, filter.field, fieldProps);
    });
  }, [filters, fieldProps]);
  var onSubmit = React__default['default'].useCallback(function (values) {
    var where = Object.keys(values).reduce(function (prev, key) {
      if (!___default['default'].isNil(values[key])) {
        prev[key] = values[key];
      } else {
        prev = ___default['default'].omit(prev, key);
      }

      return prev;
    }, _objectSpread$1({}, data));
    setFilters(where);
  }, [model, data, setFilters]);
  var onChange = options && options.submitOnChange == true ? onSubmit : undefined;
  return fields && filters.length ? /*#__PURE__*/React__default['default'].createElement(xadminForm.Form, {
    onSubmit: onSubmit,
    onChange: onChange,
    fields: fields,
    component: function component(props) {
      return /*#__PURE__*/React__default['default'].createElement(FilterForm, _extends({}, props, {
        component: _component
      }));
    },
    group: group,
    initialValues: data || {},
    options: options
  }) : null;
};

var filter = function filter(name, componentName, groupName) {
  return function (_ref) {
    var model = _ref.model;
    return model && model.filters && model.filters[name] ? /*#__PURE__*/React__default['default'].createElement(BaseFilter, {
      name: name,
      component: xadminUi.C(componentName),
      group: groupName && xadminUi.C(groupName)
    }) : null;
  };
};

var filter$1 = {
  name: 'xadmin.filter',
  components: {
    'Model.BaseFilter': BaseFilter
  },
  blocks: {
    'model.list.nav': filter('navform', 'Filter.NavForm', 'Form.InlineGroup'),
    'model.list.navbtn': filter('nav', 'Filter.Modal'),
    'model.list.submenu': filter('submenu', 'Filter.Submenu', 'Form.ColGroup'),
    'model.list.sidemenu': filter('sidemenu', 'Filter.Form', 'Form.SimpleGroup')
  },
  hooks: {
    'model.list.filter': function modelListFilter() {
      var _use3 = app$1.use('model'),
          model = _use3.model,
          atoms = _use3.atoms;

      var _use4 = app$1.use('form'),
          form = _use4.form;

      var setFilters = recoil.useSetRecoilState(atoms.where('filters'));
      var resetFilter = React__default['default'].useCallback(function () {
        var initial = ___default['default'].isFunction(model.initialValues) ? model.initialValues() : model.initialValues;
        var where = initial && initial.wheres && initial.wheres.filters || {};
        form.reset(where);
        setFilters(where);
      }, [model, setFilters]);
      React__default['default'].useEffect(function () {
        if (model.filterDefault) {
          var values = ___default['default'].isFunction(model.filterDefault) ? model.filterDefault() : model.filterDefault;
          form.reset(values);
        }
      }, [model.filterDefault]);
      return {
        resetFilter: resetFilter
      };
    }
  },
  filter_converter: filter_converter
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var actions = {
  items: {
    modelBatchActions: {
      type: 'map'
    }
  },
  modelBatchActions: {
    edit: {
      "default": true,
      component: function component(props) {
        var model = props.model;

        if (model.batchChangeFields && !!model.permission && !!model.permission.edit) {
          return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, _extends({
            is: "Model.BatchChange"
          }, props));
        } else {
          return null;
        }
      }
    },
    "delete": {
      "default": true,
      component: function component(props) {
        var model = props.model;

        if (!!model.permission && !!model.permission["delete"]) {
          return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, _extends({
            is: "Model.BatchDelete"
          }, props));
        } else {
          return null;
        }
      }
    }
  },
  hooks: {
    'model.batchActions': function modelBatchActions() {
      var _use = app$1.use('model'),
          model = _use.model;

      var modelActions = app__default['default'].get('modelBatchActions');
      var actions = model.batchActions === undefined ? Object.keys(modelActions).filter(function (k) {
        return modelActions[k]["default"];
      }) : model.batchActions;
      var renderActions = React__default['default'].useCallback(function (actProps) {
        return actions ? actions.map(function (action, i) {
          var Action = ___default['default'].isString(action) && modelActions[action] ? modelActions[action].component : action;

          if (Action) {
            return /*#__PURE__*/React__default['default'].createElement(Action, _extends({
              key: "model--batch-action-".concat(i)
            }, actProps));
          }

          return null;
        }).filter(Boolean) : null;
      }, [actions]);
      return {
        actions: actions,
        renderActions: renderActions
      };
    },
    'actons.batch_delete': function actonsBatch_delete(args) {
      var _use2 = app$1.use('model'),
          model = _use2.model,
          rest = _use2.rest,
          atoms = _use2.atoms;

      var _use3 = app$1.use('model.getItems'),
          getItems = _use3.getItems;

      var message = app$1.use('message');

      var _use4 = app$1.use('model.permission'),
          canDelete = _use4.canDelete;

      var loading = recoil.useRecoilValue(atoms.loading('delete_items'));
      var onBatchDelete = recoil.useRecoilCallback(function (_ref) {
        var snapshot = _ref.snapshot,
            set = _ref.set,
            reset = _ref.reset;
        return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var items, object, noticeMessage;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  items = snapshot.getLoadable(atoms.selected).contents;
                  set(atoms.loading('delete_items'), true);
                  _context.prev = 2;

                  if (!rest.batchSave) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 6;
                  return rest.batchSave(items.map(function (item) {
                    return item.id;
                  }));

                case 6:
                  _context.next = 10;
                  break;

                case 8:
                  _context.next = 10;
                  return Promise.all(items.map(function (item) {
                    return rest["delete"](item.id);
                  }));

                case 10:
                  // clear selected
                  reset(atoms.selected); // show message

                  if (message !== null && message !== void 0 && message.success && (args === null || args === void 0 ? void 0 : args.successMessage) !== false) {
                    object = model.title || model.name;
                    noticeMessage = ___default['default'].isString(args === null || args === void 0 ? void 0 : args.successMessage) ? args.successMessage : xadminI18n._t('Delete {{object}} success', {
                      object: object
                    });
                    message === null || message === void 0 ? void 0 : message.success(noticeMessage);
                  } // get items


                  getItems();
                  return _context.abrupt("return", null);

                case 16:
                  _context.prev = 16;
                  _context.t0 = _context["catch"](2);
                  app__default['default'].error(_context.t0);
                  throw _context.t0.formError || _context.t0.json || _context.t0;

                case 20:
                  _context.prev = 20;
                  set(atoms.loading('delete_items'), false);
                  return _context.finish(20);

                case 23:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 16, 20, 23]]);
        }));
      }, [getItems, model]);
      return {
        loading: loading,
        canDelete: canDelete,
        onBatchDelete: onBatchDelete
      };
    },
    'actons.batch_change': function actonsBatch_change(args) {
      var _use5 = app$1.use('model'),
          model = _use5.model,
          rest = _use5.rest,
          atoms = _use5.atoms;

      var _use6 = app$1.use('model.getItems'),
          getItems = _use6.getItems;

      var message = app$1.use('message');

      var _use7 = app$1.use('model.permission'),
          canEdit = _use7.canEdit;

      var loading = recoil.useRecoilValue(atoms.loading('save_items'));
      var onBatchChange = recoil.useRecoilCallback(function (_ref3) {
        var snapshot = _ref3.snapshot,
            set = _ref3.set;
        return /*#__PURE__*/function () {
          var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(value) {
            var items, ret, object, noticeMessage;
            return regenerator.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    items = snapshot.getLoadable(atoms.selected).contents;
                    set(atoms.loading('save_items'), true);
                    _context2.prev = 2;

                    if (!rest.batchDelte) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 6;
                    return rest.batchDelte(items, value);

                  case 6:
                    ret = _context2.sent;
                    _context2.next = 12;
                    break;

                  case 9:
                    _context2.next = 11;
                    return Promise.all(items.map(function (item) {
                      return rest.save(_objectSpread({
                        id: item.id
                      }, value), true);
                    }));

                  case 11:
                    ret = _context2.sent;

                  case 12:
                    // show message
                    if (message !== null && message !== void 0 && message.success && (args === null || args === void 0 ? void 0 : args.successMessage) !== false) {
                      object = model.title || model.name;
                      noticeMessage = ___default['default'].isString(args === null || args === void 0 ? void 0 : args.successMessage) ? args.successMessage : xadminI18n._t('Batch Save {{object}} success', {
                        object: object
                      });
                      message === null || message === void 0 ? void 0 : message.success(noticeMessage);
                    } // update items


                    if (___default['default'].isNil(ret) || ___default['default'].isEmpty(ret)) {
                      getItems();
                    } else {
                      ret.forEach(function (item) {
                        return set(atoms.item(item.id), item);
                      });
                    }

                    return _context2.abrupt("return", ret);

                  case 17:
                    _context2.prev = 17;
                    _context2.t0 = _context2["catch"](2);
                    app__default['default'].error(_context2.t0);
                    throw _context2.t0.formError || _context2.t0.json || _context2.t0;

                  case 21:
                    _context2.prev = 21;
                    set(atoms.loading('save_items'), false);
                    return _context2.finish(21);

                  case 24:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, null, [[2, 17, 21, 24]]);
          }));

          return function (_x) {
            return _ref4.apply(this, arguments);
          };
        }();
      }, [getItems, model]);
      return {
        loading: loading,
        fields: model.batchChangeFields || [],
        canEdit: canEdit,
        onBatchChange: onBatchChange
      };
    }
  }
};

var search = {
  name: 'xadmin.model.search',
  blocks: {
    'model.list.nav': function modelListNav(props) {
      return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, _extends({
        is: "Model.SearchBar",
        key: "searchBar"
      }, props));
    }
  },
  hooks: {
    'model.searchbar': function modelSearchbar() {
      var _React$useState = React__default['default'].useState(null),
          _React$useState2 = _slicedToArray(_React$useState, 2),
          searchValue = _React$useState2[0],
          setSearch = _React$useState2[1];

      var setSearchFilter = app$1.use('model.setter', 'where', 'searchbar');

      var _use = app$1.use('model'),
          model = _use.model;

      var searchFields = model.searchFields;
      var searchTitles = model.searchFields && model.searchFields.map(function (field) {
        return model.properties[field].title || field;
      });
      var onSearch = React__default['default'].useCallback(function (search) {
        if (search) {
          var searchs = model.searchFields.map(function (field) {
            return _defineProperty({}, field, {
              like: search
            });
          });

          if (searchs.length > 1) {
            setSearchFilter({
              or: searchs
            });
          } else if (searchs.length > 0) {
            setSearchFilter(searchs[0]);
          }
        } else {
          setSearchFilter(null);
        }

        setSearch(search);
      }, [model.searchFields, setSearch, setSearchFilter]);
      return {
        searchValue: searchValue,
        searchFields: searchFields,
        searchTitles: searchTitles,
        onSearch: onSearch
      };
    }
  }
};

var ItemModalForm = function ItemModalForm() {
  var _use = app$1.use('model'),
      model = _use.model;

  var message = app$1.use('message');

  var _use2 = app$1.use('model.permission'),
      canAdd = _use2.canAdd,
      canEdit = _use2.canEdit;

  var _use3 = app$1.use('model.save'),
      saveItem = _use3.saveItem;

  var _use4 = app$1.use('model.getItems'),
      getItems = _use4.getItems;

  var _use5 = app$1.use('model.state', 'modalItem'),
      _use6 = _slicedToArray(_use5, 2),
      modalItemId = _use6[0],
      setModalItemId = _use6[1];

  var _use7 = app$1.use('model.item', {
    id: modalItemId
  }),
      data = _use7.data,
      loading = _use7.loading;

  var hideLoading = React__default['default'].useRef();
  var show = !_.isNil(modalItemId);

  var hideModal = function hideModal() {
    return setModalItemId(null);
  };

  var onSubmitSuccess = function onSubmitSuccess(item) {
    hideModal();
    getItems();
  };

  React__default['default'].useEffect(function () {
    if (message !== null && message !== void 0 && message.loading) {
      if (loading) {
        hideLoading.current = message === null || message === void 0 ? void 0 : message.loading(xadminI18n._t('Loading data'));
      } else if (hideLoading.current) {
        hideLoading.current();
        hideLoading.current = null;
      }
    }
  }, [loading]);
  var hasPermission = (data === null || data === void 0 ? void 0 : data.id) == undefined && canAdd || (data === null || data === void 0 ? void 0 : data.id) != undefined && canEdit;
  return hasPermission && show && !loading ? /*#__PURE__*/React__default['default'].createElement(xadminForm.SchemaForm, _extends({
    formKey: "model.modalform.".concat(model.key, ".").concat(modalItemId),
    schema: model,
    initialValues: data,
    onSubmit: saveItem,
    onSubmitSuccess: onSubmitSuccess
  }, model.formProps), function (props) {
    return /*#__PURE__*/React__default['default'].createElement(xadminUi.C, _extends({
      is: "Form.ModalLayout"
    }, props, {
      title: model.title,
      show: show,
      onClose: hideModal
    }));
  }) : null;
};

var modalform = {
  name: 'xadmin.model.modalform',
  blocks: {
    'model.list.navbtn': function modelListNavbtn() {
      return /*#__PURE__*/React__default['default'].createElement(ItemModalForm, null);
    }
  },
  modelAtoms: [function (k) {
    return {
      modalItem: recoil.atom({
        key: k('modalItem'),
        "default": null
      })
    };
  }],
  hooks: {
    'model.event': function modelEvent() {
      var setModalItemId = app$1.use('model.setter', 'modalItem');
      return {
        onAdd: function onAdd() {
          return setModalItemId('');
        },
        onSaved: function onSaved() {
          return setModalItemId(null);
        },
        onEdit: function onEdit(id) {
          return setModalItemId(id);
        }
      };
    }
  }
};

var reldetail = {
  name: 'xadmin.model.reldetail',
  field_render: function field_render(SubPrev, schema) {
    if (schema.type == 'object' && schema.relateTo) {
      return function (_ref) {
        var value = _ref.value,
            WrapComponent = _ref.wrap;

        if (value && value.id !== undefined && schema.showDetail === true && Object.keys(app__default['default'].get('models')).indexOf(schema.relateTo) >= 0) {
          var newWrap = function newWrap(_ref2) {
            var children = _ref2.children;
            return /*#__PURE__*/React__default['default'].createElement(Model, {
              name: schema.relateTo
            }, /*#__PURE__*/React__default['default'].createElement(WrapComponent, null, /*#__PURE__*/React__default['default'].createElement(xadminUi.C, {
              is: "Model.DetailModal",
              id: value.id
            }, children)));
          };

          return /*#__PURE__*/React__default['default'].createElement(SubPrev, {
            value: value,
            wrap: newWrap
          });
        } else {
          return /*#__PURE__*/React__default['default'].createElement(SubPrev, {
            value: value,
            wrap: WrapComponent
          });
        }
      };
    }

    return SubPrev;
  }
};

var app = {
  name: 'xadmin.model',
  items: {
    models: {
      type: 'map'
    },
    fieldRenders: {
      type: 'array'
    },
    modelActions: {
      type: 'map'
    },
    modelAtoms: {
      type: 'array'
    }
  },
  components: {
    'Model.Routes': ModelRoutes
  },
  blocks: function blocks(app) {
    var models = app.get('models');
    return {
      'main.menu': function mainMenu() {
        return Object.keys(models).map(function (name) {
          var _model$permission, _model$ui, _model$ui2;

          var model = models[name];

          if ((_model$permission = model.permission) !== null && _model$permission !== void 0 && _model$permission.view && (_model$ui = model.ui) !== null && _model$ui !== void 0 && _model$ui.showMenu && (_model$ui2 = model.ui) !== null && _model$ui2 !== void 0 && _model$ui2.menuPath) {
            return /*#__PURE__*/React__default['default'].createElement(xadminUi.Menu.Item, {
              itemKey: "main-menu-item-model-".concat(name),
              onItemClick: function onItemClick() {
                return app.go(model.ui.menuPath);
              },
              icon: /*#__PURE__*/React__default['default'].createElement(xadminUi.Icon, {
                name: model.icon || name
              })
            }, model.title);
          }
        }).filter(function (item) {
          return item !== undefined;
        });
      }
    };
  },
  routers: function routers(app) {
    var models = app.get('models');
    var _t = app.context._t;
    var routes = {
      '/app/': [{
        path: 'model'
      }]
    };
    var autoModelRoutes = app.config('autoModelRoutes');
    var defaultRootRoute = '/app/model';

    if (autoModelRoutes === false) {
      return routes;
    } else if (___default['default'].isString(autoModelRoutes)) {
      defaultRootRoute = autoModelRoutes;
    }

    var _loop = function _loop(name) {
      var model = models[name];
      var modelName = model.title || model.name;
      var rs = ___default['default'].isArray(model.route) ? model.route : [model.route || {
        parentPath: defaultRootRoute,
        path: name
      }];
      rs.forEach(function (r) {
        var parent = r.parentPath || '/';
        var path = ___default['default'].isString(r) ? r : r.path;

        if (!routes[parent]) {
          routes[parent] = [];
        }

        routes[parent].push({
          path: "".concat(path, "/*"),
          breadcrumbName: _t('{{name}} List', {
            name: modelName
          }),
          element: /*#__PURE__*/React__default['default'].createElement(Model, {
            key: "model.".concat(parent, ".").concat(path),
            name: name
          }, /*#__PURE__*/React__default['default'].createElement(ModelRoutes, null))
        });
      });
    };

    for (var name in models) {
      _loop(name);
    }

    return routes;
  },
  hooks: hooks,
  fieldRenders: fieldRenders,
  modelActions: {
    edit: {
      "default": true,
      component: xadminUi.C.lazy('Model.ActionEdit')
    },
    "delete": {
      "default": true,
      component: xadminUi.C.lazy('Model.ActionDelete')
    }
  }
};
var apps = {
  relate: relate,
  filter: filter$1,
  actions: actions,
  search: search,
  modalform: modalform,
  reldetail: reldetail
};

exports.Model = Model;
exports.ModelBlock = ModelBlock;
exports.ModelContext = ModelContext;
exports.ModelRoutes = ModelRoutes;
exports.apps = apps;
exports.default = app;
exports.utils = utils;

Object.defineProperty(exports, '__esModule', { value: true });

})));
