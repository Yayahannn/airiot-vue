function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { useState, useEffect, useContext, useCallback, useMemo } from 'react';
import _ from 'lodash';
import { app, config, use, api } from 'xadmin';
import { _t } from 'xadmin-i18n';
import { getFieldProp } from './utils';
import { ModelContext } from './base';
import { useRecoilState, useRecoilValue, useSetRecoilState, useRecoilCallback } from 'recoil';

var useModelRecoilAtom = (atom, fkey) => {
  var model = useContext(ModelContext);

  if (!model) {
    throw Error('Need Model Context when use model hooks.');
  }

  var state = atom;

  if (_.isFunction(atom)) {
    state = atom(model.atoms);
  } else if (_.isString(atom)) {
    state = model.atoms[atom];

    if (_.isNil(state)) {
      throw Error("Model atom ".concat(atom, " undefined."));
    }

    if (fkey) {
      state = state(fkey);
    }
  }

  return state;
};

var useModelValue = (atom, fkey) => {
  return useRecoilValue(useModelRecoilAtom(atom, fkey));
};

var useModelState = (atom, fkey) => {
  return useRecoilState(useModelRecoilAtom(atom, fkey));
};

var useSetModelState = (atom, fkey) => {
  return useSetRecoilState(useModelRecoilAtom(atom, fkey));
};

var useModelCallback = (cb, deps) => {
  var {
    model,
    atoms
  } = use('model');
  return useRecoilCallback(proxy => {
    proxy.atoms = atoms;
    return cb(proxy);
  }, [...deps, model]);
};

export default {
  'model': () => {
    var model = useContext(ModelContext);

    if (!model) {
      throw Error('Need Model Context when use model hooks.');
    }

    var rest = useMemo(() => api(model), [model]);
    return {
      model,
      rest,
      atoms: model.atoms
    };
  },
  'model.value': useModelValue,
  'model.setter': useSetModelState,
  'model.state': useModelState,
  'model.callback': useModelCallback,
  // Get Model Item
  'model.get': (_ref) => {
    var {
      id,
      query,
      item
    } = _ref;
    var {
      model,
      rest
    } = use('model');
    var defaultData = React.useMemo(() => {
      var data = item;

      if (!data) {
        if (model.defaultValue) {
          data = _.isFunction(model.defaultValue) ? model.defaultValue() : model.defaultValue;
        }

        if (!_.isEmpty(query)) {
          data = _objectSpread(_objectSpread({}, data), query);
        }
      }

      return data;
    }, [item, model.defaultValue, query]);
    var [state, setState] = useState(() => ({
      data: defaultData,
      loading: Boolean(!defaultData && id)
    }));
    useEffect(() => {
      var {
        data
      } = state;

      if (id && (data === null || data === void 0 ? void 0 : data.id) != id) {
        setState({
          data,
          loading: true
        });
        rest.get(id).then(payload => {
          setState({
            data: payload,
            loading: false
          });
        });
      } else {
        setState({
          data: defaultData,
          loading: false
        });
      }
    }, [id]);
    var title = id ? _t('Edit {{title}}', {
      title: model.title
    }) : _t('Create {{title}}', {
      title: model.title
    });
    return _objectSpread({
      model,
      title
    }, state);
  },
  // Save Model Item
  'model.save': props => {
    var {
      model,
      rest
    } = use('model');
    var message = use('message');
    var successMessage = props === null || props === void 0 ? void 0 : props.successMessage;
    var saveItem = useModelCallback((_ref2) => {
      var {
        snapshot,
        set,
        atoms
      } = _ref2;
      return /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function* (item, partial) {
          set(atoms.loading('save'), true);

          try {
            if (model.partialSave || item['__partial__']) {
              partial = true;
            }

            var data = yield rest.save(item, partial);
            var id = data.id || item.id;
            var newData = data || item;

            if (partial) {
              var oldItem = snapshot.getLoadable(atoms.item(id)).contents;
              newData = _objectSpread(_objectSpread({}, oldItem), newData);
            }

            set(atoms.item(id), newData); // change selected item

            var selected = snapshot.getLoadable(atoms.selected).contents;
            set(atoms.selected, selected.map(i => i.id !== id ? i : newData));

            if (message !== null && message !== void 0 && message.success && successMessage !== false) {
              var object = model.title || model.name;
              var noticeMessage = successMessage || (item.id == undefined ? _t('Create {{object}} success', {
                object
              }) : _t('Save {{object}} success', {
                object
              }));
              message.success(noticeMessage);
            }

            return data;
          } catch (err) {
            app.error(err);
            throw err.formError || err.json || err;
          } finally {
            set(atoms.loading('save'), false);
          }
        });

        return function (_x, _x2) {
          return _ref3.apply(this, arguments);
        };
      }();
    }, []);
    return {
      model,
      saveItem
    };
  },
  // Delete Model Item
  'model.delete': props => {
    var {
      model,
      rest
    } = use('model');
    var {
      getItems
    } = use('model.getItems');
    var message = use('message');
    var deleteMessage = props === null || props === void 0 ? void 0 : props.deleteMessage;
    var itemId = props === null || props === void 0 ? void 0 : props.id;
    var deleteItem = useModelCallback((_ref4) => {
      var {
        snapshot,
        set,
        atoms
      } = _ref4;
      return /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator(function* (id) {
          id = id || itemId;
          yield rest.delete(id); // unselect

          var selected = snapshot.getLoadable(atoms.selected).contents;
          set(atoms.selected, selected.filter(i => {
            return i.id !== id;
          }));
          (message === null || message === void 0 ? void 0 : message.success) && message.success(deleteMessage || _t('Delete {{object}} success', {
            object: model.title || model.name
          })); // getItems

          yield getItems();
        });

        return function (_x3) {
          return _ref5.apply(this, arguments);
        };
      }();
    }, [itemId]);
    return {
      model,
      deleteItem
    };
  },
  // Delete Model Item
  'model.getItems': () => {
    var {
      model,
      rest
    } = use('model');
    var getItems = useModelCallback((_ref6) => {
      var {
        snapshot: ss,
        set,
        reset,
        atoms
      } = _ref6;
      return /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator(function* (query) {
          var _ref8 = query || {},
              {
            wheres: newWheres
          } = _ref8,
              newOption = _objectWithoutProperties(_ref8, ["wheres"]);

          var wheres = newWheres || ss.getLoadable(atoms.wheres).contents;

          var option = _objectSpread(_objectSpread({}, ss.getLoadable(atoms.option).contents), newOption);

          set(atoms.loading('items'), true);

          try {
            var {
              items,
              total
            } = yield rest.query(option, wheres);
            set(atoms.items, items);
            set(atoms.count, total);
            if (!_.isEmpty(newOption)) set(atoms.option, option);
            if (newWheres) set(atoms.wheres, wheres);
            return {
              items,
              total
            };
          } catch (error) {
            app.error(error);
            reset(atoms.ids);
            reset(atoms.count);
            throw error;
          } finally {
            set(atoms.loading('items'), false);
          }
        });

        return function (_x4) {
          return _ref7.apply(this, arguments);
        };
      }();
    }, []);
    return {
      model,
      getItems
    };
  },
  // Model Item hooks
  'model.item': props => {
    return _objectSpread(_objectSpread(_objectSpread({}, use('model.get', props)), use('model.save', props)), use('model.delete', props));
  },
  'model.query': () => {
    var {
      model,
      rest
    } = use('model');
    var [data, setData] = useState(null);
    var [loading, setLoading] = useState(false);
    useEffect(() => {
      setLoading(true);
      rest.query().then((_ref9) => {
        var {
          items,
          count
        } = _ref9;
        setData(items);
        setLoading(false);
      });
    }, []);
    return {
      items: data,
      loading,
      model
    };
  },
  'model.permission': () => {
    var {
      model
    } = use('model');
    return {
      canAdd: !!model.permission && !!model.permission.add,
      canDelete: !!model.permission && !!model.permission.delete,
      canEdit: !!model.permission && !!model.permission.edit
    };
  },
  'model.event': () => {
    var {
      model
    } = use('model');
    var nav = use('navigate');
    return _objectSpread({
      onAdd: () => nav("../add"),
      onSaved: () => history && history.length > 1 && history.back() || nav("../"),
      onBack: () => history && history.length > 1 && history.back() || nav(-1),
      onEdit: id => nav("../".concat(encodeURIComponent(id || props.id), "/edit"))
    }, model.events);
  },
  // Model effect hook
  'model.effect': () => {
    var {
      model
    } = use('model');
    var {
      getItems
    } = use('model.getItems');
    var option = useModelValue('option');
    var wheres = useModelValue('wheres');
    React.useEffect(() => {
      if (model.initQuery === false) {
        model.initQuery = undefined;
        return;
      }

      getItems();
    }, [option, wheres]);
    return null;
  },
  'model.pagination': () => {
    var atoms = use('model.atoms');
    var count = useModelValue('count');
    var limit = useModelValue('limit');
    var [skip, setSkip] = useModelState('skip');
    var items = Math.ceil(count / limit);
    var activePage = Math.floor(skip / limit) + 1;
    var changePage = useCallback(page => {
      var skip = limit * (page - 1);
      setSkip(skip);
    }, [setSkip, limit]);
    return {
      items,
      activePage,
      changePage
    };
  },
  'model.count': () => ({
    count: useModelValue('count')
  }),
  'model.pagesize': () => {
    var [limit, setLimit] = useModelState('limit');
    var setSkip = useSetModelState('skip');
    var sizes = config('pageSizes', [15, 30, 50, 100]);
    var setPageSize = useCallback(size => {
      setLimit(size);
      setSkip(0);
    }, [setLimit, setSkip]);
    return {
      sizes,
      setPageSize,
      size: limit
    };
  },
  'model.fields': () => {
    var {
      model
    } = use('model');
    var [selectedFields, setFields] = useModelState('fields');
    var changeFieldDisplay = useCallback((_ref10) => {
      var [field, selected] = _ref10;
      var fs = [...selectedFields];

      var index = _.indexOf(fs, field);

      if (selected) {
        if (index === -1) fs.push(field);
      } else {
        _.remove(fs, i => {
          return i === field;
        });
      }

      var list = Array.from(new Set([...model.listFields, ...Object.keys(model.properties)]));
      setFields(list.filter(f => fs.indexOf(f) >= 0));
    }, [selectedFields, model, setFields]);
    return {
      fields: model.properties,
      changeFieldDisplay,
      selected: selectedFields
    };
  },
  'model.list': () => {
    use('model.effect');
    var items = useModelValue('items');
    var selected = useModelValue('selected');
    var fields = useModelValue('fields');
    var loading = useModelValue('loading', 'items');
    return {
      loading,
      items,
      fields,
      selected
    };
  },
  'model.actions': () => {
    var {
      model
    } = use('model');
    var modelActions = app.get('modelActions');
    var actions = model.itemActions === undefined ? Object.keys(modelActions).filter(k => modelActions[k].default) : model.itemActions;
    var renderActions = React.useCallback(actProps => {
      return actions ? actions.map((action, i) => {
        var Action = _.isString(action) && modelActions[action] ? modelActions[action].component : action;

        if (Action) {
          return /*#__PURE__*/React.createElement(Action, _extends({
            key: "model-action-".concat(i)
          }, actProps));
        }

        return null;
      }).filter(Boolean) : null;
    }, [actions]);
    return {
      actions,
      renderActions
    };
  },
  'model.select': () => {
    var {
      atoms
    } = use('model');
    var selected = useModelValue('selected');
    var [isSelectedAll, onSelectAll] = useModelState('allSelected');
    var onSelect = useModelCallback((_ref11) => {
      var {
        set,
        atoms
      } = _ref11;
      return (item, isSelect) => {
        set(atoms.itemSelected(item.id), isSelect);
      };
    }, []);
    return {
      count: selected.length,
      selected,
      isSelectedAll,
      onSelect,
      onSelectAll
    };
  },
  'model.list.row': (_ref12) => {
    var {
      id
    } = _ref12;
    var {
      model
    } = use('model');
    var item = useModelValue('item', id);
    var [itemSelected, changeSelect] = useModelState('itemSelected', id);
    return {
      selected: itemSelected,
      item,
      changeSelect,
      actions: model.itemActions || ['edit', 'delete']
    };
  },
  'model.list.header': (_ref13) => {
    var {
      field
    } = _ref13;
    var {
      model
    } = use('model');
    var property = getFieldProp(model, field) || {};

    var title = property.header || property.title || _.startCase(field);

    return {
      title
    };
  },
  'model.list.order': (_ref14) => {
    var {
      field
    } = _ref14;
    var {
      model
    } = use('model');
    var property = getFieldProp(model, field) || {};
    var canOrder = property.canOrder !== undefined ? property.canOrder : property.orderField !== undefined || property.type != 'object' && property.type != 'array';
    var [itemOrder, changeOrder] = useModelState('itemOrder', property.orderField || field);
    return {
      changeOrder,
      canOrder,
      order: itemOrder
    };
  },
  'model.list.item': (_ref15) => {
    var {
      schema,
      field,
      item,
      nest
    } = _ref15;
    var {
      model
    } = use('model');
    var property = schema || getFieldProp(model, field);
    var data = schema ? {} : {
      schema: property
    };
    var key = schema ? "".concat(schema.name, ".").concat(field) : field;

    if (model.fieldRender == undefined) {
      model.fieldRender = {};
    }

    if (model.fieldRender[key] == undefined) {
      model.fieldRender[key] = property != undefined ? app.get('fieldRenders').reduce((prev, render) => {
        return render(prev, property, field);
      }, null) : null;
    }

    if (model.fieldRender[key]) {
      data['componentClass'] = model.fieldRender[key];
    }

    data['value'] = _.get(item, field);
    data['editable'] = nest == true || model.editableFields == undefined || model.editableFields.indexOf(field) < 0;
    return data;
  }
};