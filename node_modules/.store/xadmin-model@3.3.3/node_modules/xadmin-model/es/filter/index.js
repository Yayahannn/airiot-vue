function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from 'react';
import _ from 'lodash';
import app, { use } from 'xadmin';
import { Form } from 'xadmin-form';
import { C } from 'xadmin-ui';
import { getFieldProp } from '../utils';
import filter_converter from './filters';
import { useRecoilState, useSetRecoilState } from 'recoil';

var convert = (schema, options) => {
  var opts = options || {};
  return app.load_list('filter_converter').reduce((prve, converter) => {
    return converter(prve, schema, opts);
  }, {});
};

var FilterForm = props => {
  var {
    component: FilterComponent
  } = props,
      filterForm = _objectWithoutProperties(props, ["component"]);

  var {
    resetFilter
  } = use('model.list.filter');
  return /*#__PURE__*/React.createElement(FilterComponent, _extends({}, filterForm, {
    resetFilter: resetFilter
  }));
};

var BaseFilter = props => {
  var {
    name,
    component: _component,
    group,
    fieldProps
  } = props;
  var {
    model,
    atoms
  } = use('model');
  var [data, setFilters] = useRecoilState(atoms.where('filters'));
  var {
    filters,
    options,
    formKey
  } = React.useMemo(() => {
    var formKey = "filter.".concat(model.key || model.name);
    var filter = model.filters && model.filters[name];
    var fields, options;

    if (_.isArray(filter)) {
      options = {};
      fields = filter;
    } else if (_.isPlainObject(filter) && _.isArray(filter.fields)) {
      fields = filter.fields;
      options = _.omit(filter, 'fields');
    } else {
      return {
        filters: [],
        formKey,
        options: {}
      };
    }

    var filters = fields.map(field => {
      var key = typeof field == 'string' ? field : field.key;
      var schema = getFieldProp(model, key);
      return schema ? {
        key,
        schema,
        field: typeof field == 'string' ? {} : field
      } : null;
    }).filter(Boolean);
    return {
      filters,
      formKey,
      options
    };
  }, [model, name]);
  var fields = React.useMemo(() => filters.map(filter => {
    var field = convert(filter.schema, {
      key: filter.key
    });
    return _.merge(field, filter.field, fieldProps);
  }), [filters, fieldProps]);
  var onSubmit = React.useCallback(values => {
    var where = Object.keys(values).reduce((prev, key) => {
      if (!_.isNil(values[key])) {
        prev[key] = values[key];
      } else {
        prev = _.omit(prev, key);
      }

      return prev;
    }, _objectSpread({}, data));
    setFilters(where);
  }, [model, data, setFilters]);
  var onChange = options && options.submitOnChange == true ? onSubmit : undefined;
  return fields && filters.length ? /*#__PURE__*/React.createElement(Form, {
    onSubmit: onSubmit,
    onChange: onChange,
    fields: fields,
    component: props => /*#__PURE__*/React.createElement(FilterForm, _extends({}, props, {
      component: _component
    })),
    group: group,
    initialValues: data || {},
    options: options
  }) : null;
};

var filter = (name, componentName, groupName) => (_ref) => {
  var {
    model
  } = _ref;
  return model && model.filters && model.filters[name] ? /*#__PURE__*/React.createElement(BaseFilter, {
    name: name,
    component: C(componentName),
    group: groupName && C(groupName)
  }) : null;
};

export default {
  name: 'xadmin.filter',
  components: {
    'Model.BaseFilter': BaseFilter
  },
  blocks: {
    'model.list.nav': filter('navform', 'Filter.NavForm', 'Form.InlineGroup'),
    'model.list.navbtn': filter('nav', 'Filter.Modal'),
    'model.list.submenu': filter('submenu', 'Filter.Submenu', 'Form.ColGroup'),
    'model.list.sidemenu': filter('sidemenu', 'Filter.Form', 'Form.SimpleGroup')
  },
  hooks: {
    'model.list.filter': () => {
      var {
        model,
        atoms
      } = use('model');
      var {
        form
      } = use('form');
      var setFilters = useSetRecoilState(atoms.where('filters'));
      var resetFilter = React.useCallback(() => {
        var initial = _.isFunction(model.initialValues) ? model.initialValues() : model.initialValues;
        var where = initial && initial.wheres && initial.wheres.filters || {};
        form.reset(where);
        setFilters(where);
      }, [model, setFilters]);
      React.useEffect(() => {
        if (model.filterDefault) {
          var values = _.isFunction(model.filterDefault) ? model.filterDefault() : model.filterDefault;
          form.reset(values);
        }
      }, [model.filterDefault]);
      return {
        resetFilter
      };
    }
  },
  filter_converter
};
export { BaseFilter };