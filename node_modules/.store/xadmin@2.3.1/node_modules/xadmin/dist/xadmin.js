(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('react-redux'), require('lodash'), require('react-router'), require('redux'), require('redux-saga')) :
typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'react-redux', 'lodash', 'react-router', 'redux', 'redux-saga'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.xadmin = {}, global.React, global.ReactDOM, global.ReactRedux, global._, global.ReactRouter, global.Redux, global.ReduxSaga));
}(this, (function (exports, React, ReactDOM, reactRedux, _, reactRouter, redux, createSagaMiddleware) { 'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var createSagaMiddleware__default = /*#__PURE__*/_interopDefaultLegacy(createSagaMiddleware);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

var noop_1 = noop;

var once_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = once;
function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports["default"];
});

unwrapExports(once_1);

var slice_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = slice;
function slice(arrayLike, start) {
    start = start | 0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
}
module.exports = exports["default"];
});

unwrapExports(slice_1);

var onlyOnce_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onlyOnce;
function onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}
module.exports = exports["default"];
});

unwrapExports(onlyOnce_1);

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

var initialParams = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (fn) {
    return function () /*...args, callback*/{
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
    };
};



var _slice2 = _interopRequireDefault(slice_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
});

unwrapExports(initialParams);

var setImmediate_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasNextTick = exports.hasSetImmediate = undefined;
exports.fallback = fallback;
exports.wrap = wrap;



var _slice2 = _interopRequireDefault(slice_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return function (fn /*, ...args*/) {
        var args = (0, _slice2.default)(arguments, 1);
        defer(function () {
            fn.apply(null, args);
        });
    };
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports.default = wrap(_defer);
});

unwrapExports(setImmediate_1);
setImmediate_1.hasNextTick;
setImmediate_1.hasSetImmediate;
setImmediate_1.fallback;
setImmediate_1.wrap;

var asyncify_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = asyncify;



var _isObject2 = _interopRequireDefault(isObject_1);



var _initialParams2 = _interopRequireDefault(initialParams);



var _setImmediate2 = _interopRequireDefault(setImmediate_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if ((0, _isObject2.default)(result) && typeof result.then === 'function') {
            result.then(function (value) {
                invokeCallback(callback, null, value);
            }, function (err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (e) {
        (0, _setImmediate2.default)(rethrow, e);
    }
}

function rethrow(error) {
    throw error;
}
module.exports = exports['default'];
});

unwrapExports(asyncify_1);

var wrapAsync_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAsync = undefined;



var _asyncify2 = _interopRequireDefault(asyncify_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportsSymbol = typeof Symbol === 'function';

function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
}

function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}

exports.default = wrapAsync;
exports.isAsync = isAsync;
});

unwrapExports(wrapAsync_1);
wrapAsync_1.isAsync;

var waterfall = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (tasks, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
    }

    function next(err /*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
    }

    nextTask([]);
};



var _isArray2 = _interopRequireDefault(isArray_1);



var _noop2 = _interopRequireDefault(noop_1);



var _once2 = _interopRequireDefault(once_1);



var _slice2 = _interopRequireDefault(slice_1);



var _onlyOnce2 = _interopRequireDefault(onlyOnce_1);



var _wrapAsync2 = _interopRequireDefault(wrapAsync_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
});

var waterfall$1 = unwrapExports(waterfall);

var App = /*#__PURE__*/function () {
  function App() {
    _classCallCheck(this, App);

    this.apps = [];
    this.items = {};
    this.context = {};
    this._cache = {};
    this.started = false;
  }

  _createClass(App, [{
    key: "checkAddItems",
    value: function checkAddItems(items) {
      var _this = this;

      items && Object.keys(items).forEach(function (key) {
        if (_this.items[key] != undefined) {
          throw Error("Repeatedly defined configuration item '".concat(key, "'"));
        } else {
          _this.items[key] = items[key];
        }
      });
    }
  }, {
    key: "use",
    value: function use(app) {
      var _app = app.app || app;

      if (_app) {
        this.checkAddItems(_app.items);
        this.apps.push(_app);
      }

      return this;
    }
  }, {
    key: "unuse",
    value: function unuse(name) {
      var _this2 = this;

      this.apps = this.apps.reduce(function (prev, app) {
        if (app.name != name) {
          prev.push(app);
        } else if (app.items) {
          Object.keys(app.items).forEach(function (key) {
            return delete _this2.items[key];
          });
        }

        return prev;
      }, []);
      return this;
    }
  }, {
    key: "items",
    value: function items() {
      this.items;
    }
  }, {
    key: "getItem",
    value: function getItem(key) {
      var item = this.items[key];

      if (item == undefined) {
        throw Error("Not defined configuration item '".concat(key, "'"));
      }

      return item;
    }
  }, {
    key: "$",
    value: function $(key) {
      return this.get(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      var item = this.getItem(key);

      if (item.reducer && item.init) {
        return this.reduce(key, item.reducer, item.init);
      }

      switch (item.type) {
        case 'array':
          return this.array(key);

        case 'mapArray':
          return this.mapArray(key);

        case 'map':
        default:
          return this.map(key);
      }
    }
  }, {
    key: "getValue",
    value: function getValue(value) {
      if (typeof value == 'function' && value.length == 1) {
        if (value.constructor.name == 'GeneratorFunction') {
          var it = value(this);

          return it;
        } else {
          return value(this);
        }
      } else {
        return value;
      }
    }
  }, {
    key: "reduce",
    value: function reduce(key, load_reducer) {
      var init_state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!this.started) {
        throw Error('App not started, can\'t use app item.');
      }

      if (this._cache[key] == undefined) {
        this._cache[key] = this.apps.reduce(function (prev, app) {
          return app[key] !== undefined ? load_reducer(prev, app[key]) : prev;
        }, init_state) || init_state;
      }

      return this._cache[key];
    }
  }, {
    key: "map",
    value: function map(key) {
      var _this3 = this;

      return this.reduce(key, function (prev, value) {
        return _objectSpread2(_objectSpread2({}, prev), _this3.getValue(value));
      }, {});
    }
  }, {
    key: "array",
    value: function array(key) {
      var _this4 = this;

      return this.reduce(key, function (prev, value) {
        return prev.concat(_this4.getValue(value));
      }, []);
    }
  }, {
    key: "mapArray",
    value: function mapArray(key) {
      var _this5 = this;

      return this.reduce(key, function (prev, value) {
        var values = _this5.getValue(value);

        for (var _key in values) {
          prev[_key] = prev[_key] || [];
          var com_value = values[_key];

          if (Array.isArray(com_value)) {
            prev[_key] = prev[_key].concat(com_value);
          } else {
            prev[_key].push(com_value);
          }
        }

        return prev;
      }, {});
    }
  }, {
    key: "load_dict",
    value: function load_dict(key) {
      return this.map(key);
    }
  }, {
    key: "load_list",
    value: function load_list(key) {
      return this.array(key);
    }
  }, {
    key: "load_dict_list",
    value: function load_dict_list(key) {
      return this.mapArray(key);
    }
  }, {
    key: "config",
    value: function config(key) {
      return this.get('config')[key];
    }
  }, {
    key: "start",
    value: function start() {
      var init_context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var self = this;
      this.started = true;
      waterfall$1([function (cb) {
        cb(null, init_context);
      }].concat(_toConsumableArray(this.get('context').map(function (func) {
        return function (context, cb) {
          return func(context, function (err, newContext) {
            self.context = newContext;
            cb(err, newContext);
          });
        };
      }))), function (err, context) {
        self.context = context;
        self.get('start').forEach(function (starter) {
          starter(self);
        });
      });
    }
  }, {
    key: "log",
    value: function log(level, message, error) {
      this.get('logger').forEach(function (logger) {
        return logger(level, message, error);
      });
    }
  }, {
    key: "error",
    value: function error(err) {
      this.log('error', err.toString(), err);
    }
  }]);

  return App;
}();

var redux_app = {
  items: {
    reducers: {
      type: 'mapArray'
    },
    'redux/subscribe': {
      type: 'array'
    },
    'redux/on_create': {
      type: 'array'
    },
    'redux/middlewares': {
      type: 'array'
    },
    'redux/store_enhancers': {
      type: 'array'
    },
    'redux/reducer_enhance': {
      type: 'mapArray'
    }
  },
  context: function context(app) {
    return function (context, cb) {
      var enhancers = [redux.applyMiddleware.apply(void 0, _toConsumableArray(app.get('redux/middlewares')))].concat(_toConsumableArray(app.$('redux/store_enhancers')));

      var combine_reducer = function combine_reducer(key, reducers) {
        if (reducers.length > 1) {
          return function (state, action) {
            return reducers.reduce(function (prev, reducer) {
              return reducer(prev, action);
            }, state);
          };
        } else {
          return reducers[0];
        }
      };

      var create_reducers = function create_reducers() {
        var reducers_map = app.get('reducers');
        var reducers = {};

        for (var key in reducers_map) {
          reducers[key] = combine_reducer(key, reducers_map[key]);
        }

        return redux.combineReducers(reducers);
      };

      var composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || redux.compose; // create store

      var store = redux.createStore(create_reducers(), context['initial_state'] || {}, composeEnhancers.apply(void 0, _toConsumableArray(enhancers)));
      cb(null, _objectSpread2(_objectSpread2({}, context), {}, {
        store: store
      }));
    };
  },
  start: function start(app) {
    return function () {
      // store change
      var store = app.context.store;
      var listeners = app.get('redux/subscribe');

      var _iterator = _createForOfIteratorHelper(listeners),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          store.subscribe(listener);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      app.get('redux/on_create').forEach(function (callback) {
        return callback(store);
      });
    };
  }
}; // saga app

var sagaMiddleware = createSagaMiddleware__default['default']();
var sage_app = {
  items: {
    effects: {
      type: 'array'
    }
  },
  context: function context(app) {
    return function (context, cb) {
      // extend store
      var store = context.store;
      store.runSaga = sagaMiddleware.run; // start saga

      var effects = app.get('effects');
      effects.forEach(sagaMiddleware.run);
      cb(null, context);
    };
  },
  'redux/middlewares': function reduxMiddlewares(app) {
    return sagaMiddleware;
  }
}; // react & react-router app

var react_app = {
  items: {
    routers: {
      type: 'mapArray'
    },
    root_component: {
      type: 'array'
    }
  },
  context: function context(app) {
    return function (context, cb) {
      app.go = function (uri) {
        app.context.router.push(uri);
      };

      var routerType = app.config('router') || 'browser';
      var router = typeof routerType === 'string' ? {
        browser: reactRouter.browserHistory,
        hash: reactRouter.hashHistory
      }[routerType] : routerType;
      cb(null, _objectSpread2(_objectSpread2({}, context), {}, {
        router: router
      }));
    };
  },
  start: function start(app) {
    return function () {
      // init container
      var _app$context$containe = app.context.container,
          container = _app$context$containe === void 0 ? '#app' : _app$context$containe;

      if (typeof container === 'string') {
        container = document.querySelector(container);
      }

      var rs = app.get('routers');

      var find_childs = function find_childs(path) {
        return (rs[path] || []).map(function (r) {
          var childs = find_childs((path == '@' ? '' : path) + r.path);
          return childs.length > 0 ? _objectSpread2(_objectSpread2({}, r), {}, {
            childRoutes: [].concat(_toConsumableArray(r.childRoutes || []), _toConsumableArray(childs))
          }) : r;
        });
      };

      var routers = find_childs('@');
      var root = app.get('root_component').reduce(function (children, render) {
        return render(children);
      }, routers && routers.length ? /*#__PURE__*/React__default['default'].createElement(reactRouter.Router, {
        history: app.context.router,
        routes: routers[0]
      }) : /*#__PURE__*/React__default['default'].createElement("span", null, "Please config routers or Main component."));
      ReactDOM__default['default'].render(root, container);
    };
  }
}; // react-redux app

var react_redux_app = {
  root_component: function root_component(app) {
    return function (children) {
      return /*#__PURE__*/React__default['default'].createElement(reactRedux.Provider, {
        store: app.context.store
      }, children);
    };
  },
  hooks: function hooks(app) {
    return {
      'redux': function redux(props, select) {
        var store = app.context.store;
        var getState = store.getState,
            dispatch = store.dispatch,
            subscribe = store.subscribe;

        if (select) {
          var state = getState();

          var _React$useState = React__default['default'].useState(select(state) || {}),
              _React$useState2 = _slicedToArray(_React$useState, 2),
              values = _React$useState2[0],
              setValues = _React$useState2[1];

          var lastValues = React__default['default'].useRef();
          lastValues.current = values;

          var updateState = function updateState() {
            var newValues = select(getState());

            if (!___default['default'].isEqual(lastValues.current, newValues)) {
              setValues(newValues);
            }
          };

          React__default['default'].useEffect(function () {
            return subscribe(updateState);
          }, []);
          return _objectSpread2(_objectSpread2({}, props), {}, {
            store: store,
            dispatch: dispatch,
            state: state
          }, values);
        } else {
          return _objectSpread2(_objectSpread2({}, props), {}, {
            store: store,
            dispatch: dispatch,
            state: getState()
          });
        }
      }
    };
  }
};
var rrs = (function (app) {
  return app.use(redux_app).use(sage_app).use(react_app).use(react_redux_app);
});

var RESTBaseAPI = /*#__PURE__*/function () {
  function RESTBaseAPI(options) {
    _classCallCheck(this, RESTBaseAPI);

    this.options = options;
    this.resource = options.resource || options.name;
  }

  _createClass(RESTBaseAPI, [{
    key: "getHost",
    value: function getHost() {
      return '/';
    }
  }, {
    key: "fetch",
    value: function fetch(id, options) {
      throw 'App API not implement!!!';
    }
  }, {
    key: "count",
    value: function count() {
      return this.fetch().then(function (ds) {
        return ds.length;
      });
    }
  }, {
    key: "query",
    value: function query() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.fetch().then(function (ds) {
        return {
          total: ds.length,
          items: ds.slice(filter.skip || 0, (filter.skip || 0) + parseInt(filter.limit || 15))
        };
      });
    }
  }, {
    key: "get",
    value: function get() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return this.fetch(id);
    }
  }, {
    key: "delete",
    value: function _delete(id) {
      return this.fetch(id, {
        method: 'DELETE'
      });
    }
  }, {
    key: "put",
    value: function put(id, data) {
      return this.fetch(id, {
        method: 'PUT',
        body: JSON.stringify(data)
      }).then(function (item) {
        return _objectSpread2(_objectSpread2({}, data), item);
      });
    }
  }, {
    key: "patch",
    value: function patch(id, data) {
      return this.fetch(id, {
        method: 'PATCH',
        body: JSON.stringify(data)
      }).then(function (item) {
        return _objectSpread2(_objectSpread2({}, data), item);
      });
    }
  }, {
    key: "post",
    value: function post(data) {
      return this.fetch(null, {
        method: 'POST',
        body: JSON.stringify(data)
      }).then(function (item) {
        return _objectSpread2(_objectSpread2({}, data), item);
      });
    }
  }, {
    key: "save",
    value: function save(data, partial) {
      if (data.id) {
        var id = data.id;

        if (partial) {
          return this.patch(id, data);
        }

        return this.put(id, data);
      } else {
        return this.post(data);
      }
    }
  }]);

  return RESTBaseAPI;
}();

var block = function block(tag) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var app = window.__app__;
  var blocks = app.get('blocks');

  if (blocks[tag] !== undefined) {
    var nodes = blocks[tag].reduce(function (prev, block) {
      var ret = block(_objectSpread2({
        nodes: prev
      }, props));

      if (ret != undefined && ret != null && ret != prev) {
        if (Array.isArray(ret)) {
          prev = prev.concat(ret.map(function (c) {
            return /*#__PURE__*/React__default['default'].cloneElement(c, props);
          }));
        } else if ( /*#__PURE__*/React__default['default'].isValidElement(ret)) {
          prev.push( /*#__PURE__*/React__default['default'].cloneElement(ret, props));
        }
      }

      return prev;
    }, []);

    if (nodes.length && nodes.filter(function (node) {
      return node !== null;
    }).length > 0) {
      return nodes;
    }
  }

  return null;
};

var Block = function Block(_ref) {
  var name = _ref.name,
      children = _ref.children,
      props = _objectWithoutProperties(_ref, ["name", "children"]);

  var bs = block(name, props);
  return ___default['default'].isFunction(children) ? children(bs ? React__default['default'].Children.toArray(bs) : null) : React__default['default'].Children.toArray(bs);
};

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

var shallowEqual = function shallowEqual(objA, objB, ingoreKey) {
  if (objA === objB) {
    return true;
  }

  if (objA == undefined && objB != undefined || objB == undefined && objA != undefined || objA == null && objB != null || objB == null && objA != null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  var hasOwn = Object.prototype.hasOwnProperty;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || keysA[i] != ingoreKey && objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
};

var wrap_component = function wrap_component(WrappedComponent, tag, defaultMapper) {
  var app = window.__app__;
  var mappers = null;

  var getMappers = function getMappers() {
    if (mappers == null) {
      mappers = (defaultMapper !== undefined ? [defaultMapper] : []).concat(tag && app.get('mappers')[tag] || []);
    }

    return mappers;
  };

  var computeDataProps = function computeDataProps(_ref) {
    var wrapContext = _ref.wrapContext,
        props = _objectWithoutProperties(_ref, ["wrapContext"]);

    return getMappers().reduce(function (prev, mapper) {
      return ___default['default'].isFunction(mapper.data) ? _objectSpread2(_objectSpread2({}, prev), mapper.data(wrapContext, props, prev)) : prev;
    }, {});
  };

  var computeComputeProps = function computeComputeProps(_ref2) {
    var wrapContext = _ref2.wrapContext,
        props = _objectWithoutProperties(_ref2, ["wrapContext"]);

    return getMappers().reduce(function (prev, mapper) {
      return ___default['default'].isFunction(mapper.compute) ? _objectSpread2(_objectSpread2({}, prev), mapper.compute(wrapContext, props, prev)) : prev;
    }, {});
  };

  var Connect = /*#__PURE__*/function (_React$Component) {
    _inherits(Connect, _React$Component);

    var _super = _createSuper(Connect);

    function Connect() {
      var _this;

      _classCallCheck(this, Connect);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.methodProps = null;
      _this.state = {};
      return _this;
    }

    _createClass(Connect, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        return !shallowEqual(this.state, nextState) || !shallowEqual(this.props, nextProps, 'wrapContext');
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var _this2 = this;

        getMappers().forEach(function (mapper) {
          if (mapper.event && mapper.event.update) {
            _this2.runBindMethod(mapper.event.update, _this2);
          }
        });
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this3 = this;

        getMappers().forEach(function (mapper) {
          if (mapper.event && mapper.event.mount) {
            _this3.runBindMethod(mapper.event.mount, _this3);
          }
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this4 = this;

        getMappers().forEach(function (mapper) {
          if (mapper.event && mapper.event.unmount) {
            _this4.runBindMethod(mapper.event.unmount, _this4);
          }
        });
      }
    }, {
      key: "runBindMethod",
      value: function runBindMethod(method, args) {
        var _this$state = this.state,
            dataProps = _this$state.dataProps,
            computeProps = _this$state.computeProps;
        return method(this.props.wrapContext, _objectSpread2(_objectSpread2(_objectSpread2({}, this.props), dataProps), computeProps), args);
      }
    }, {
      key: "computeMethodProps",
      value: function computeMethodProps() {
        var bindMethod = this.runBindMethod.bind(this);
        return getMappers().reduce(function (prev, mapper) {
          if (mapper.method === undefined) {
            return prev;
          }

          var methods = mapper.method;
          var bindMethods = {};

          var _loop = function _loop(key) {
            var method = methods[key];

            bindMethods[key] = function () {
              return bindMethod(method).apply(void 0, arguments);
            };
          };

          for (var key in methods) {
            _loop(key);
          }

          return _objectSpread2(_objectSpread2({}, prev), bindMethods);
        }, {});
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state2 = this.state,
            forwardedRef = _this$state2.forwardedRef,
            dataProps = _this$state2.dataProps,
            computeProps = _this$state2.computeProps;

        if (this.methodProps == null) {
          this.methodProps = this.computeMethodProps();
        }

        return /*#__PURE__*/React__default['default'].createElement(WrappedComponent, _extends({
          ref: forwardedRef
        }, ___default['default'].omit(this.props, 'wrapContext'), dataProps, computeProps, this.methodProps));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var dataProps = computeDataProps(props);

        if (shallowEqual(dataProps, state.dataProps)) {
          return null;
        }

        var computeProps = computeComputeProps(_objectSpread2(_objectSpread2({}, props), dataProps));
        return {
          dataProps: dataProps,
          computeProps: computeProps
        };
      }
    }]);

    return Connect;
  }(React__default['default'].Component);

  return /*#__PURE__*/React__default['default'].forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default['default'].createElement(Connect, _extends({}, props, {
      ref: ref
    }));
  });
};

var wrap = function wrap(magic, mapper) {
  var wrappers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (___default['default'].isFunction(magic)) {
    return function (arg1, arg2) {
      return wrap(arg1, arg2, [magic].concat(_toConsumableArray(wrappers)));
    };
  } else {
    return function (component) {
      var Connect = wrap_component(component, ___default['default'].isPlainObject(magic) ? null : magic, ___default['default'].isPlainObject(magic) ? magic : mapper);
      var ContextComponent = wrappers.reduce(function (prev, wrapper) {
        return wrapper(prev);
      }, Connect);
      ContextComponent.displayName = "Connect(".concat(getDisplayName(component), ")");
      ContextComponent.WrappedComponent = component;
      return ContextComponent;
    };
  }
};

var Wrap = wrap(function (Connect) {
  return Connect;
});

var StoreConnect = function StoreConnect(_ref3) {
  var store = _ref3.store,
      subscription = _ref3.subscription,
      children = _ref3.children;

  var _useState = React.useState(store.getState()),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  React.useEffect(function () {
    return subscription.addNestedSub(function () {
      setState(store.getState());
    });
  }, [store, subscription]);
  return children(state);
};

var StoreWrap = wrap(function (Connect) {
  return function (props) {
    return /*#__PURE__*/React__default['default'].createElement(reactRedux.ReactReduxContext.Consumer, null, function (_ref4) {
      var store = _ref4.store,
          subscription = _ref4.subscription;
      return /*#__PURE__*/React__default['default'].createElement(StoreConnect, {
        store: store,
        subscription: subscription
      }, function (state) {
        return /*#__PURE__*/React__default['default'].createElement(Connect, _extends({}, props, {
          wrapContext: {
            store: store,
            dispatch: store.dispatch,
            state: state
          }
        }));
      });
    });
  };
});

var base = {
  items: {
    config: {
      type: 'map'
    },
    context: {
      type: 'array'
    },
    start: {
      type: 'array'
    },
    logger: {
      type: 'array'
    },
    blocks: {
      type: 'mapArray'
    },
    mappers: {
      type: 'mapArray'
    },
    hooks: {
      type: 'mapArray'
    }
  }
};

if (window.__app__ == undefined) {
  window.__app__ = rrs(new App().use(base));
}

var app = window.__app__;

var config = function config(key, default_value) {
  return app.get('config')[key] || default_value;
};

var api = function api(opt) {
  var API = config('api');

  if (API) {
    return new API(opt);
  } else {
    throw 'App API not implement!!!';
  }
};

var use = function use(key, props, select) {
  var hooks = app.get('hooks')[key];

  if (typeof props == 'function' && select == undefined) {
    select = props;
    props = {};
  }

  return hooks ? hooks.reduce(function (prev, hook) {
    return hook(prev, select);
  }, props || {}) : props || {};
};

exports.Block = Block;
exports.RESTBaseAPI = RESTBaseAPI;
exports.StoreWrap = StoreWrap;
exports.Wrap = Wrap;
exports.api = api;
exports.app = app;
exports.config = config;
exports.default = app;
exports.use = use;
exports.wrap = wrap;

Object.defineProperty(exports, '__esModule', { value: true });

})));
