function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { useEffect, useState } from 'react';
import _ from 'lodash';
import { ReactReduxContext } from 'react-redux';

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

var shallowEqual = (objA, objB, ingoreKey) => {
  if (objA === objB) {
    return true;
  }

  if (objA == undefined && objB != undefined || objB == undefined && objA != undefined || objA == null && objB != null || objB == null && objA != null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  var hasOwn = Object.prototype.hasOwnProperty;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || keysA[i] != ingoreKey && objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
};

var wrap_component = (WrappedComponent, tag, defaultMapper) => {
  var app = window.__app__;
  var mappers = null;

  var getMappers = () => {
    if (mappers == null) {
      mappers = (defaultMapper !== undefined ? [defaultMapper] : []).concat(tag && app.get('mappers')[tag] || []);
    }

    return mappers;
  };

  var computeDataProps = (_ref) => {
    var {
      wrapContext
    } = _ref,
        props = _objectWithoutProperties(_ref, ["wrapContext"]);

    return getMappers().reduce((prev, mapper) => _.isFunction(mapper.data) ? _objectSpread(_objectSpread({}, prev), mapper.data(wrapContext, props, prev)) : prev, {});
  };

  var computeComputeProps = (_ref2) => {
    var {
      wrapContext
    } = _ref2,
        props = _objectWithoutProperties(_ref2, ["wrapContext"]);

    return getMappers().reduce((prev, mapper) => _.isFunction(mapper.compute) ? _objectSpread(_objectSpread({}, prev), mapper.compute(wrapContext, props, prev)) : prev, {});
  };

  class Connect extends React.Component {
    constructor() {
      super(...arguments);
      this.methodProps = null;
      this.state = {};
    }

    static getDerivedStateFromProps(props, state) {
      var dataProps = computeDataProps(props);

      if (shallowEqual(dataProps, state.dataProps)) {
        return null;
      }

      var computeProps = computeComputeProps(_objectSpread(_objectSpread({}, props), dataProps));
      return {
        dataProps,
        computeProps
      };
    }

    shouldComponentUpdate(nextProps, nextState) {
      return !shallowEqual(this.state, nextState) || !shallowEqual(this.props, nextProps, 'wrapContext');
    }

    componentDidUpdate() {
      getMappers().forEach(mapper => {
        if (mapper.event && mapper.event.update) {
          this.runBindMethod(mapper.event.update, this);
        }
      });
    }

    componentDidMount() {
      getMappers().forEach(mapper => {
        if (mapper.event && mapper.event.mount) {
          this.runBindMethod(mapper.event.mount, this);
        }
      });
    }

    componentWillUnmount() {
      getMappers().forEach(mapper => {
        if (mapper.event && mapper.event.unmount) {
          this.runBindMethod(mapper.event.unmount, this);
        }
      });
    }

    runBindMethod(method, args) {
      var {
        dataProps,
        computeProps
      } = this.state;
      return method(this.props.wrapContext, _objectSpread(_objectSpread(_objectSpread({}, this.props), dataProps), computeProps), args);
    }

    computeMethodProps() {
      var bindMethod = this.runBindMethod.bind(this);
      return getMappers().reduce((prev, mapper) => {
        if (mapper.method === undefined) {
          return prev;
        }

        var methods = mapper.method;
        var bindMethods = {};

        var _loop = function _loop(key) {
          var method = methods[key];

          bindMethods[key] = function () {
            return bindMethod(method)(...arguments);
          };
        };

        for (var key in methods) {
          _loop(key);
        }

        return _objectSpread(_objectSpread({}, prev), bindMethods);
      }, {});
    }

    render() {
      var {
        forwardedRef,
        dataProps,
        computeProps
      } = this.state;

      if (this.methodProps == null) {
        this.methodProps = this.computeMethodProps();
      }

      return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
        ref: forwardedRef
      }, _.omit(this.props, 'wrapContext'), dataProps, computeProps, this.methodProps));
    }

  }

  return /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(Connect, _extends({}, props, {
    ref: ref
  })));
};

var wrap = function wrap(magic, mapper) {
  var wrappers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (_.isFunction(magic)) {
    return (arg1, arg2) => {
      return wrap(arg1, arg2, [magic, ...wrappers]);
    };
  } else {
    return component => {
      var Connect = wrap_component(component, _.isPlainObject(magic) ? null : magic, _.isPlainObject(magic) ? magic : mapper);
      var ContextComponent = wrappers.reduce((prev, wrapper) => wrapper(prev), Connect);
      ContextComponent.displayName = "Connect(".concat(getDisplayName(component), ")");
      ContextComponent.WrappedComponent = component;
      return ContextComponent;
    };
  }
};

var Wrap = wrap(Connect => Connect);

var StoreConnect = (_ref3) => {
  var {
    store,
    subscription,
    children
  } = _ref3;
  var [state, setState] = useState(store.getState());
  useEffect(() => subscription.addNestedSub(() => {
    setState(store.getState());
  }), [store, subscription]);
  return children(state);
};

var StoreWrap = wrap(Connect => props => /*#__PURE__*/React.createElement(ReactReduxContext.Consumer, null, (_ref4) => {
  var {
    store,
    subscription
  } = _ref4;
  return /*#__PURE__*/React.createElement(StoreConnect, {
    store: store,
    subscription: subscription
  }, state => /*#__PURE__*/React.createElement(Connect, _extends({}, props, {
    wrapContext: {
      store,
      dispatch: store.dispatch,
      state: state
    }
  })));
}));
export { Wrap, StoreWrap, wrap };