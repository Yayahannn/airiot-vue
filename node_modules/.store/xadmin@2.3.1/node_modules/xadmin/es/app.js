function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import waterfall from 'async/waterfall';
export default class App {
  constructor() {
    this.apps = [];
    this.items = {};
    this.context = {};
    this._cache = {};
    this.started = false;
  }

  checkAddItems(items) {
    items && Object.keys(items).forEach(key => {
      if (this.items[key] != undefined) {
        throw Error("Repeatedly defined configuration item '".concat(key, "'"));
      } else {
        this.items[key] = items[key];
      }
    });
  }

  use(app) {
    var _app = app.app || app;

    if (_app) {
      this.checkAddItems(_app.items);
      this.apps.push(_app);
    }

    return this;
  }

  unuse(name) {
    this.apps = this.apps.reduce((prev, app) => {
      if (app.name != name) {
        prev.push(app);
      } else if (app.items) {
        Object.keys(app.items).forEach(key => delete this.items[key]);
      }

      return prev;
    }, []);
    return this;
  }

  items() {
    this.items;
  }

  getItem(key) {
    var item = this.items[key];

    if (item == undefined) {
      throw Error("Not defined configuration item '".concat(key, "'"));
    }

    return item;
  }

  $(key) {
    return this.get(key);
  }

  get(key) {
    var item = this.getItem(key);

    if (item.reducer && item.init) {
      return this.reduce(key, item.reducer, item.init);
    }

    switch (item.type) {
      case 'array':
        return this.array(key);

      case 'mapArray':
        return this.mapArray(key);

      case 'map':
      default:
        return this.map(key);
    }
  }

  getValue(value) {
    if (typeof value == 'function' && value.length == 1) {
      if (value.constructor.name == 'GeneratorFunction') {
        var it = value(this);

        var go = result => {
          if (result.done) return result.value;
          return result.value.then(v => {
            return go(it.next(v));
          }, error => {
            return go(it.throw(error));
          });
        };

        return it;
      } else {
        return value(this);
      }
    } else {
      return value;
    }
  }

  reduce(key, load_reducer) {
    var init_state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!this.started) {
      throw Error('App not started, can\'t use app item.');
    }

    if (this._cache[key] == undefined) {
      this._cache[key] = this.apps.reduce((prev, app) => {
        return app[key] !== undefined ? load_reducer(prev, app[key]) : prev;
      }, init_state) || init_state;
    }

    return this._cache[key];
  }

  map(key) {
    return this.reduce(key, (prev, value) => {
      return _objectSpread(_objectSpread({}, prev), this.getValue(value));
    }, {});
  }

  array(key) {
    return this.reduce(key, (prev, value) => {
      return prev.concat(this.getValue(value));
    }, []);
  }

  mapArray(key) {
    return this.reduce(key, (prev, value) => {
      var values = this.getValue(value);

      for (var _key in values) {
        prev[_key] = prev[_key] || [];
        var com_value = values[_key];

        if (Array.isArray(com_value)) {
          prev[_key] = prev[_key].concat(com_value);
        } else {
          prev[_key].push(com_value);
        }
      }

      return prev;
    }, {});
  }

  load_dict(key) {
    return this.map(key);
  }

  load_list(key) {
    return this.array(key);
  }

  load_dict_list(key) {
    return this.mapArray(key);
  }

  config(key) {
    return this.get('config')[key];
  }

  start() {
    var init_context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var self = this;
    this.started = true;
    waterfall([cb => {
      cb(null, init_context);
    }, ...this.get('context').map(func => (context, cb) => func(context, (err, newContext) => {
      self.context = newContext;
      cb(err, newContext);
    }))], (err, context) => {
      self.context = context;
      self.get('start').forEach(starter => {
        starter(self);
      });
    });
  }

  log(level, message, error) {
    this.get('logger').forEach(logger => logger(level, message, error));
  }

  error(err) {
    this.log('error', err.toString(), err);
  }

}